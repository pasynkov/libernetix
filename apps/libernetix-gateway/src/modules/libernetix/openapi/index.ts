/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/purchases/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a purchase – the main request for any e-commerce integration.
         * @description To run payments in your application use `POST /purchases/`, request to register payments and receive the checkout link (`checkout_url`). After the payment is processed, gateway will redirect the client back to your website (take note of `success_redirect`, `failure_redirect`).
         *
         *     You have three options to check payment status: 1) use `success_callback` parameter of `Purchase` object; 2) use `GET /purchases/<purchase_id>/` request; 3) set up a Webhook using the UI or Webhook API to listen to `purchase.paid` or `purchase.payment_failure` event on your server.
         *
         *     Using `skip_capture` flag allows you to separate the authentication and payment execution steps, allowing you to reserve funds on payer’s card account for some time. This flag can also enable preauthorization capability, allowing you to save the card without a financial transaction, if available.
         *
         *     In case making a purchase client agrees to store his card for the upcoming purchases, next time he will be able to pay in a single click.
         *
         *     Instead of a redirect you can also utilize Direct Post checkout: you can create an HTML `<form>` on your website with `method="POST"` and `action` pointing to `direct_post_url` of a created Purchase. You will also need to saturate form with `<input>`-s for card data fields. As a result, when a payer submits their card data, it will be posted straight to our system, allowing you to customize the checkout as you wish while your PCI DSS requirement is only raised to SAQ A-EP, as your system doesn't receive or process card data. For more details, see the documentation on Purchase's `direct_post_url` field.
         *
         *     To pay for test Purchases, use `4444 3333 2222 1111` as the card number, `123` as CVC, any date/month greater than now as expiry and any (Latin) cardholder name. Any other card number/CVC/expiry not greater or equal than the current month will all fail a test payment.
         */
        post: operations["purchases_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve an object by ID. */
        get: operations["purchases_read"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/cancel/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel a pending purchase.
         * @description If you have a Purchase that payment is possible for, using this request you can guarantee that it won't be paid.
         */
        post: operations["purchases_cancel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/release/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Release funds on hold.
         * @description Release funds reserved for a Purchase (`status == hold`). You can place a `hold` (authenticate the payment) using `skip_capture == true` when creating the Purchase and ensuring your client submits the payment form.
         *
         *     If this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 and a Purchase object having `status` = `pending_release` in body (you will receive a corresponding Webhook callback too for a `purchase.pending_release` event). To be notified of a successful operation completion, please subscribe to `purchase.released` callback event - it will deliver an updated Purchase with `status` = `released`.
         *
         *     If fund release fails due to payment processing error, you will receive HTTP response code 400 with error code `purchase_release_error`. In this case, to get more details about the error, you should perform a `GET /purchase/` request for the Purchase you tried to release funds for. In `transaction_data.attempts[]` array (newest element first) you'll find the corresponding attempt with error code and description in `.error` parameter.
         */
        post: operations["purchases_release"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/capture/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture a previously authorized payment.
         * @description Capture funds reserved for a Purchase (`status == hold`). You can place a `hold` (authenticate the payment) using `skip_capture == true` when creating the Purchase and ensuring your client submits the payment form.
         *
         *     If this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 and a Purchase object having `status` = `pending_capture` in body (you will receive a corresponding Webhook callback too for a `purchase.pending_capture` event). To be notified of a successful operation completion, please subscribe to `purchase.captured` callback event - it will deliver an updated Purchase with `status` = `paid`.
         *
         *     If capture fails due to payment processing error, you will receive HTTP response code 400 with error code `purchase_capture_error`. In this case, to get more details about the error, you should perform a `GET /purchase/` request for the Purchase you tried to capture. In `transaction_data.attempts[]` array (newest element first) you'll find the corresponding attempt with error code and description in `.error` parameter. By default the full amount is captured, the `amount` body param is optional.
         */
        post: operations["purchases_capture"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/charge/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Charge or Hold a purchase using a saved token.
         * @description Charge or Hold a purchase using a `recurring_token` provided in the request body. Its value should be an `id` of a Purchase that has `is_recurring_token == true`. This purchase will be paid using the same method (e.g. same card) as the one used to pay the `recurring_token` purchase. The Hold will be performed if the Purchase this method is used on has `skip_capture`: `true`.
         *
         *     If this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 and a Purchase object having `status` = `pending_charge` in body (you will receive a corresponding Webhook callback too for a `purchase.pending_charge` event). To be notified of a successful operation completion, please subscribe to `purchase.paid` (or `purchase.hold`) callback event - it will deliver an updated Purchase with `status` = `paid` or `hold` respectively. Alternatively, if charge fails, you will receive a `purchase.payment_failure` callback event.
         *
         *     If recurring charge fails due to payment processing error, you will receive HTTP response code 400 with error code `purchase_charge_error`. In this case, to get more details about the error, you should perform a `GET /purchase/` request for the Purchase you tried to charge. In `transaction_data.attempts[]` array (newest element first) you'll find the corresponding attempt with error code and description in `.error` parameter.
         */
        post: operations["purchases_charge"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/delete_recurring_token/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete a recurring token associated with a purchase.
         * @description Will set `is_recurring_token` to `false`. You won't be able to use this Purchase's ID as a `recurring_token` anymore. The respective ClientRecurringToken, if any, will also be deleted.
         *
         *     If this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 a corresponding Webhook callback for a `purchase.pending_recurring_token_delete` event. To be notified of a successful operation completion, please subscribe to `purchase.recurring_token_deleted` callback event.
         */
        post: operations["purchases_delete_recurring_token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/refund/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refund a paid purchase.
         * @description Will generate a Payment object and return it as a successful response.
         *
         *     Optional `amount` argument can be included in the request body to request a partial refund.
         *
         *     Consult `refund_availability` field on Purchase on details whether this Purchase can be refunded or not.
         *
         *     If this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 and a Purchase object having `status` = `pending_refund` in body (you will receive a corresponding Webhook callback too for a `purchase.pending_refund` event). To be notified of a successful operation completion, please subscribe to `payment.refunded` callback event - it will deliver a Payment generated by this refund.
         *
         *     If refund fails due to payment processing error, you will receive HTTP response code 400 with error code `purchase_refund_error`. In this case, to get more details about the error, you should perform a `GET /purchase/` request for the Purchase you tried to refund. In `transaction_data.attempts[]` array (newest element first) you'll find the corresponding attempt with error code and description in `.error` parameter.
         */
        post: operations["purchases_refund"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/mark_as_paid/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Mark a purchase as paid.
         * @description Will set the purchase's status to `paid`. `purchase.marked_as_paid` field will also be set to true to distinguish this purchase.
         */
        post: operations["purchases_mark_as_paid"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/purchases/{id}/resend_invoice/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Re-sends invoice
         * @description Will re-send the invoice.
         */
        post: operations["purchases_resend_invoice"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment_methods/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the list of payment methods available for your purchase.
         * @description Send this request providing, at the very least, the `brand_id` and `currency` query parameters having the same values you'd use to create your Purchase. Be sure to use the same API key you'll create your Purchase with; it will define the test_mode setting used in the lookup.
         *
         *     In the response body you'll receive an object with `available_payment_methods` property containing the list of payment method names available to use with your Purchase (e.g. those codes can be used in `payment_method_whitelist` field or with `?preferred={payment_method}` option of `checkout_url`).
         *
         *     Please note that all lookup arguments must be provided via query parameters after the endpoint, e.g. the minimal call would be similar to: `GET /api/v1/payment_methods/?brand_id=75a76529-91c7-4d98-90a9-8a641d70ee52&currency=EUR`
         */
        get: operations["payment_methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payout_methods/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the list of payout methods available for your payout.
         * @description Send this request providing, at the very least, the `brand_id` and `currency` query parameters having the same values you'd use to create your Payout. Be sure to use the same API key you'll create your Payout with; it will define the test_mode setting used in the lookup.
         *
         *     In the response body you'll receive an object with `available_payout_methods` property containing the list of payout method names available to use with your Payout (e.g. those codes can be used in `payout_method_whitelist` field).
         *
         *     Please note that all lookup arguments must be provided via query parameters after the endpoint, e.g. the minimal call would be similar to: `GET /api/v1/payout_methods/?brand_id=75a76529-91c7-4d98-90a9-8a641d70ee52&currency=EUR`
         */
        get: operations["payout_methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payouts/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an unprocessed payout object. A separate request is needed to execute the payout.
         * @description To issue payouts in your application use `POST /payouts/` request to register a payout. Response will contain the payout execution url - `execution_url`. For card payouts send a POST request to `execution_url` with a JSON payload containing recipient's card details:
         *
         *     `expiry_month`: string; 1-2 digits
         *
         *     `expiry_year`: string; 1-2 digits,
         *
         *     `card_number`: string; 16-19 chars,
         *
         *     `cardholder_name`: string; 1-30 chars. <br><br>For wallet payouts, please contact support to get specific details on how to send a POST request to execution_url.<br><br>  You need to do the 2nd request within 15 minutes of creating the Payout object. Response will have a response code of 200 in case of payout initiation success (`status` attribute will be `executed` or `pending`) or an error code/message with a 400 error response code and `status` of `error`.
         *
         *     For response to the second request having a code of 200, status = `success` means that payout was already executed.
         *
         *      Second request returning status of `pending` means the payout was accepted for processing but not executed yet. In this case, transaction processing can take up to 3-5 days depending on the payout provider. Once the processing will finish, `Payout.status` will change accordingly.
         *
         *     It's advised to subscribe to `payout.failed` and `payout.success` webhook events.
         *
         *     To test card Payouts, use `card_number` of 4444 3333 2222 1111, any `cardholder_name` and `expiry_month`/`expiry_year` equal or larger to the current ones.
         */
        post: operations["payouts_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payouts/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve an object by ID. */
        get: operations["payouts_read"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send an invoice to one or several clients.
         * @description Use this endpoint to send a one time invoice(-s). Provide all data of a `BillingTemplate` (see Schemas below) and, additionally, an array of one or more BillingTemplateClients in `clients`. Purchases will be created and invoices sent, one for every Client you have specified.
         *
         *     A BillingTemplate won't be created; if you need to be able to issue repeated, similar invoices, see `POST /billing_templates/` and `POST /billing_templates/{id}/send_invoice/`.
         *
         *     Note that unlike for other requests where you can send BillingTemplate data (like `POST /billing_templates/`), `title` and `is_subscription` are read-only for `POST /billing/`.
         */
        post: operations["billing_templates_one_time_invoices"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing_templates/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all billing templates. */
        get: operations["billing_templates_list"];
        put?: never;
        /**
         * Create a template to issue repeated invoices from in the future, with or without a subscription.
         * @description BillingTemplate generates Purchase objects, either to issue one-time invoices or in a subscription.
         *
         *     It does so by copying over its' `PurchaseDetails`, one of its `BillingTemplateClient`-s and generating other fields from BillingTemplate's fields as necessary into a new `Purchase` object.
         *
         *     If `is_subscription` is `true`, it is considered to be a subscription's BillingTemplate. You will need to specify `subscription_*` fields like `subscription_period` when creating it and add BillingTemplateClient objects to its billing cycle (`POST /billing_templates/{id}/add_subscriber/`). After that the clients will receive recurring invoices (that will be paid for automatically if client saves their card) according to the BillingTemplate settings you have specified.
         *
         *     If `is_subscription` is `false`, this BillingTemplate is used to send one-time invoices. After creating it and specifying `invoice_*` fields, use `POST /billing_templates/{id}/send_invoice/` request to send the actual invoices. BillingTemplateClients for non-subscription BillingTemplates are not saved.
         */
        post: operations["billing_templates_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing_templates/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve a billing template by ID. */
        get: operations["billing_templates_read"];
        /** Update a billing template by ID. */
        put: operations["billing_templates_update"];
        post?: never;
        /** Delete a billing template by ID. */
        delete: operations["billing_templates_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing_templates/{id}/send_invoice/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send an invoice, generating a purchase from billing template data.
         * @description Use this request with a BillingTemplate having `is_subscription == false`. Specify the BillingTemplateClient data (only `client_id` field is needed) in the request body. The request will issue a Purchase by combining data of `BillingTemplate.purchase` and `BillingTemplateClient.client` and will send an invoice to your Client. Response will contain data of a created Purchase. The BillingTemplateClient will not be saved.
         */
        post: operations["billing_templates_send_invoice"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing_templates/{id}/add_subscriber/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add a billing template client and activate recurring billing (is_subscription: true).
         * @description Use this request with a BillingTemplate having `is_subscription == true`. Two scenarios are possible:
         *
         *     • If `subscription_charge_period_end == true` and/or `subscription_trial_periods > 0` (first billing should happen after 1 or more billing periods, not today), the request will create a BillingTemplateClient and start trial/schedule billing for it (as required by subscription settings). Successful response will be of form `{billing_template_client: <BillingTemplateClient object created>, purchase: null}`: no Purchase is created, `BillingTemplateClient.status` is `active` immediately.
         *
         *     • If `subscription_charge_period_end == false` and `subscription_trial_periods == 0` (first billing should occur today), the request will create a BillingTemplateClient with `status == pending` and create a Purchase. When such a Purchase is paid, the respective BillingTemplateClient will have its' subscription activated (starting from the day of payment), with its `status` changing to `active`. Successful response will be of form `{billing_template_client: <BillingTemplateClient object created>, purchase: <Purchase object created>}`: you should redirect your client to `purchase.checkout_url` for him to pay immediately (as you do with `POST /purchases/`).
         */
        post: operations["billing_templates_add_subscriber"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing_templates/{id}/clients/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** List all billing template clients for this billing template. */
        get: operations["billing_templates_clients_list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing_templates/{id}/clients/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve a billing template client by client's ID. */
        get: operations["billing_templates_clients_read"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Partially update a billing template client by client's ID. */
        patch: operations["billing_templates_clients_partial_update"];
        trace?: never;
    };
    "/clients/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all clients. */
        get: operations["clients_list"];
        put?: never;
        /**
         * Create a new client.
         * @description Client is a record of a single customer of your business. Create one for each of your clients; you will be able to issue invoices/subscriptions for them later easily using `/billing_templates/` API.
         *
         *     Each BillingTemplateClient (there can be many attached to a single BillingTemplate) will bind a single Client to a BillingTemplate.
         */
        post: operations["clients_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/clients/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve an object by ID. */
        get: operations["clients_read"];
        /** Update a client by ID. */
        put: operations["clients_update"];
        post?: never;
        /** Delete a client by ID. */
        delete: operations["clients_delete"];
        options?: never;
        head?: never;
        /** Partially update a client by ID. */
        patch: operations["clients_partial_update"];
        trace?: never;
    };
    "/clients/{id}/recurring_tokens/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /**
         * List recurring tokens saved for a client.
         * @description All of these tokens will be available in a checkout (see `Purchase.checkout_url`) if you create a Purchase with this client's ID in `client_id` field.
         *
         *     You can use one in `POST /purchases/{id}/charge/`, too. Note that you can use one client's `recurring_token` to pay a Purchase created for a different `client_id` or created with no `client_id` at all; it's not recommended to do this.
         */
        get: operations["client_recurring_tokens_list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/clients/{id}/recurring_tokens/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve an object by ID. */
        get: operations["client_recurring_tokens_read"];
        put?: never;
        post?: never;
        /**
         * Delete a client recurring token by ID.
         * @description If you create the Purchase with the respective Client's ID (in `.client_id`), he won't see this token as available on checkout page anymore.
         *
         *     You also won't be able to use the ID of this object as a `recurring_token` in `POST /purchases/{id}/charge/`. The respective Purchase will have `is_recurring_token` set to `false` (as if `POST /purchases/{recurring_token}/delete_recurring_token/` was issued).
         */
        delete: operations["client_recurring_tokens_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all webhooks. */
        get: operations["webhooks_list"];
        put?: never;
        /** Create a new webhook. */
        post: operations["webhooks_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve an object by ID. */
        get: operations["webhooks_read"];
        /** Update a webhook by ID. */
        put: operations["webhooks_update"];
        post?: never;
        /** Delete a webhook by ID. */
        delete: operations["webhooks_delete"];
        options?: never;
        head?: never;
        /** Partially update a webhook by ID. */
        patch: operations["webhooks_partial_update"];
        trace?: never;
    };
    "/public_key/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a callback public key.
         * @description Returns public key for authenticating company callback payloads
         */
        get: operations["public_key"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/account/json/balance/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get company balance.
         * @description Returns the company balance according to the provided query string filters. Multiple values can be provided for all filters except `from` and `to`, including all results matching any of these values.
         */
        get: operations["balance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/account/json/turnover/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get company turnover.
         * @description Fetches the company turnover according to the provided query string filters. Must provide exactly one `currency` filter. Multiple values can be provided for all filters except `currency`, `from` and `to`, including all results matching any of these values.
         */
        get: operations["turnover"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/balance/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get balance data.
         * @description Returns balance data, including ecommerce and bank accounts.
         */
        get: operations["balance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/company_statements/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all generated statements. */
        get: operations["company_statements_list"];
        put?: never;
        /**
         * Schedule a statement generation.
         * @description With this request, you can schedule a statement generation for a company.
         *
         *     In a response, you will get an object with the following structure. Main fields to look out for here are `id`, `status` and `download_url`.
         */
        post: operations["company_statements_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/company_statements/{id}/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** Retrieve a statement by ID. */
        get: operations["company_statements_read"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/company_statements/{id}/cancel/": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Cancel a statement generation by ID. */
        post: operations["company_statements_cancel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description Company Balance in a specific currency */
        Balance: {
            gross_balance?: components["schemas"]["MoneyAmount"] & unknown;
            balance?: components["schemas"]["MoneyAmount"] & unknown;
            available_balance?: components["schemas"]["MoneyAmount"] & unknown;
            reserved?: components["schemas"]["MoneyAmount"] & unknown;
            pending_outgoing?: components["schemas"]["MoneyAmount"] & unknown;
            fee_sell?: components["schemas"]["FeeSell"];
        };
        /**
         * @description Map of currency to company Balance for the specific currency
         * @example {
         *       "EUR": {
         *         "balance": 93408,
         *         "fee_sell": 0,
         *         "reserved": 0,
         *         "gross_balance": 93408,
         *         "pending_outgoing": 0,
         *         "available_balance": 93408
         *       },
         *       "RUB": {
         *         "balance": 1111840,
         *         "fee_sell": 360,
         *         "reserved": 0,
         *         "gross_balance": 1112200,
         *         "pending_outgoing": 0,
         *         "available_balance": 1111840
         *       },
         *       "USD": {
         *         "balance": -35420,
         *         "fee_sell": 1880,
         *         "reserved": 0,
         *         "gross_balance": -33540,
         *         "pending_outgoing": 0,
         *         "available_balance": -35420
         *       }
         *     }
         */
        BalanceByCurrency: {
            [key: string]: components["schemas"]["Balance"];
        };
        /** @description Bank account */
        BankAccount: {
            /** @description Bank account ID */
            id?: components["parameters"]["id"];
            /** @description International Bank Account Number (IBAN) */
            iban?: string;
            /** @description Society for Worldwide Interbank Financial Telecommunication (SWIFT) code */
            swift?: string;
            /** @description Bank account number */
            bank_account?: string;
            /** @description Bank code */
            bank_code?: string;
            /** @description Real bank account number */
            real_bank_account?: string;
            /** @description Real bank code */
            real_bank_code?: string;
            /** @description Currency code */
            currency?: components["schemas"]["Currency"];
            /** @description Bank account status */
            status?: string;
            /** @description Bank account name */
            name?: string;
            /** @description Bank account reference */
            reference?: string;
            /** @description Available balance */
            available_balance?: components["schemas"]["MoneyAmount"];
            /** @description Reserved balance */
            reserved_balance?: components["schemas"]["MoneyAmount"];
            /** @description Extended UI */
            extended_ui?: string;
            /** @description Foreign exchange currencies */
            fx_currencies?: components["schemas"]["Currency"][];
        };
        BankAccountMixin: {
            /** @description Bank account number (e.g. IBAN) */
            bank_account?: string;
            /** @description SWIFT/BIC code of the bank */
            bank_code?: string;
        };
        BaseModel: {
            /** @description Object type identifier */
            readonly type?: string;
            /** Format: uuid */
            readonly id?: string;
            /** @description Object creation time */
            readonly created_on?: components["schemas"]["UnixTimestamp"];
            /** @description Object last modification time */
            readonly updated_on?: components["schemas"]["UnixTimestamp"];
        };
        /** @description BillingTemplate generates Purchase objects, either to issue one-time invoices or in a subscription.
         *
         *     It does so by copying over its' `PurchaseDetails`, one of its `BillingTemplateClient`-s and generating other fields from BillingTemplate's fields as necessary into a new `Purchase` object.
         *
         *     If `is_subscription` is `true`, it is considered to be a subscription's BillingTemplate. You will need to specify `subscription_*` fields like `subscription_period` when creating it and add BillingTemplateClient objects to its billing cycle (`POST /billing_templates/{id}/add_subscriber/`). After that the clients will receive recurring invoices (that will be paid for automatically if client saves their card) according to the BillingTemplate settings you have specified.
         *
         *     If `is_subscription` is `false`, this BillingTemplate is used to send one-time invoices. After creating it and specifying `invoice_*` fields, use `POST /billing_templates/{id}/send_invoice/` request to send the actual invoices. BillingTemplateClients for non-subscription BillingTemplates are not saved. */
        BillingTemplate: {
            purchase: components["schemas"]["PurchaseDetails"];
            /** Format: uuid */
            readonly company_id?: string;
            /** @description Limits number of billing cycles for each client if set to a non-zero value */
            number_of_billing_cycles?: number;
            /** @description Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode. */
            readonly is_test?: boolean;
            /**
             * Format: uuid
             * @description ID of user who has created this object in the Billing UI, if applicable.
             */
            readonly user_id?: string | null;
            /**
             * Format: uuid
             * @description ID of the brand to create this BillingTemplate for. You can copy it down in the API section, see the "specify the ID of the Brand" link in answer to "How to setup payments on website or in mobile app?".
             */
            brand_id?: string;
            title?: string;
            /** @description Defines whether this BillingTemplate issues invoices in a recurring manner - it's a subscription - or it sends invoices only once. You can't change this parameter when you edit the BillingTemplate. If this field is `true`, you will need to specify `subscription_*` fields and `invoice_*` fields are read-only, and vice-versa. */
            is_subscription: boolean;
            /** @description Sets `issued` on the Purchase objects generated. Generated from current day in `purchase.timezone` if not provided. Read-only if `is_subscription == true`. */
            invoice_issued?: components["schemas"]["Timestamp"] | null;
            /** @description Sets `due` on the Purchase objects generated. Required if `is_subscription == false`, read-only otherwise. */
            invoice_due?: components["schemas"]["UnixTimestamp"] | null;
            /**
             * @description Sets `skip_capture` on the Purchase objects generated. `false` by default. Read-only if `is_subscription == true`.
             * @default false
             */
            invoice_skip_capture: boolean;
            /**
             * @description Sets `send_receipt` on the Purchase objects generated. `true` by default (unlike in Purchases API, where by default receipts are not sent). Read-only if `is_subscription == true`.
             * @default false
             */
            invoice_send_receipt: boolean;
            /**
             * @description Defines how often are the subscription Purchases generated. Used together with `subscription_period_units`: to issue Purchases once a month, use `"...period": 1` and `"...period_units" == "months"`.
             *
             *     Variable number of days in a month is respected; e.g. if subscription has a period of 1 month, a client had its billing cycle activated on January 30 and there are 28 days in February that year - billing scheduled for February will happen on 28th.
             *
             *     Both fields are required when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; they are read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.
             * @default 1
             */
            subscription_period: number;
            /**
             * @description See `subscription_period`.
             * @default months
             */
            subscription_period_units: components["schemas"]["PeriodUnits"];
            /**
             * @description Used to generate `due` on the Purchase objects generated. Used together with `subscription_due_period_units`: to set the final `Purchase.due` to a week after it's generated/invoice is sent, use `"...period": 1` and `"...period_units" == "weeks". Required if `is_subscription == true`, read-only otherwise.
             * @default 7
             */
            subscription_due_period: number;
            /**
             * @description See `subscription_due_period`.
             * @default days
             */
            subscription_due_period_units: components["schemas"]["PeriodUnits"];
            /**
             * @description If this is `true`, clients are charged at the end of billing periods, and vice-versa. E.g. if you add a subscriber client to a BillingTemplate, with this value being set to `false`, he will receive first invoice today, otherwise - after a single billing period (defined by `subscription_period`/`subscription_period_units`) passes.
             *
             *     Required when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.
             * @default false
             */
            subscription_charge_period_end: boolean;
            /**
             * @description How many trial periods to give the client prior to starting his billing cycle. If billing period is 1 month and you set this value to 2, subscription will automatically adjust to giving your client 2 months without payments and then charging him for the 3rd month (when exactly depends on `subscription_charge_period_end`: 3 months after the subscriber was launched for `false`, 4 for `true`). `"subscription_trial_periods": 0` disables this feature.
             *
             *     Required when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.
             * @default 0
             */
            subscription_trial_periods: number;
            /**
             * @description Whether this subscription is paused. Has the same effect as setting `"status": "subscription_paused"` for every BillingTemplateClient launched for this subscription, see the description of `status` on BillingTemplateClient for more details.
             *
             *     Ignored (read-only) if `is_subscription == false`.
             * @default false
             */
            subscription_active: boolean;
            /** @description If this is `true`, there were launched clients (`POST /billing_templates/{id}/add_subscriber/` - or subscribers that were added via the gateway system UI) for this subscription.
             *
             *     While this is `false` (it will be as long as you're only just created the template and haven't launched any subscribers), you can edit all of `subscription_*` fields.
             *
             *     If this is `true`, you're only allowed to edit `subscription_due_period`, `subscription_due_period_units` and `subscription_active`.
             *
             *     Is always `false` if `is_subscription == false`. */
            readonly subscription_has_active_clients?: boolean;
            /**
             * @description If the used payment method supports recurring payment functionality, forces the customer's payment credentials to be saved for possible later recurring payments, without giving the customer a choice in the matter.
             * @default false
             */
            force_recurring: boolean;
            /** @description Array of IDs of related Upsell campaigns. */
            upsell_campaigns?: string[];
            /**
             * Format: uuid
             * @description ID of Referral campaign.
             */
            referral_campaign_id?: string | null;
        } & components["schemas"]["BaseModel"];
        /** @description Connects a Client object to a BillingTemplate having `is_subscription = true` to store information about a single subscriber.
         *
         *      You will be able to pause an individual subscription client's cycle by PATCH-ing its' `status` field to the value of `subscription_paused`. */
        BillingTemplateClient: {
            /**
             * Format: uuid
             * @description ID of the Client object to add to the BillingTemplate. Read-only after the BillingTemplateClient has been created. Note that the same Client can be added to a BillingTemplate several times.
             */
            client_id: string;
            /** @description Only used together with number_of_billing_cycles on BillingTemplate. Shows number of billing cycles passed when number of cycles is limited */
            readonly number_of_billing_cycles_passed?: number;
            /** @description When present overrides reference for invoices generated for this client */
            invoice_reference?: string | null;
            /**
             * @description For subscriptions, you can edit (`PATCH /billing_templates/{id}/clients/{id}/`) this status between `active` and `subscription_paused` values to pause the client's subscription. Paused subscriptions run as normal, except for purchases not being created and invoices sent for them. It means that if you pause a BillingTemplateClient's monthly subscription cycle a day before the billing date, the next day the invoice will not be issued; but, if you unpause the client a day after the planned billing would have taken place, the planned billing in a month (minus one day) will happen as usual.
             *
             *     Read-only if the BillingTemplateClient is in `inactive` (internal status not managed through public API) or `pending` (see documentation for `POST /billing_templates/{id}/add_subscriber/`) statuses.
             * @default inactive
             * @enum {string}
             */
            status: "pending" | "inactive" | "active" | "subscription_paused";
            /**
             * @description If not null, reports the date when the next billing is scheduled for this client.
             * @default null
             */
            readonly subscription_billing_scheduled_on: components["schemas"]["Timestamp"] | null;
            /** @description An optional whitelist of payment methods availble for purchases generated for this BillingTemplateClient. Copied 1:1 to `Purchase.payment_method_whitelist` field on created Purchases (see its description). */
            payment_method_whitelist?: string[];
            /**
             * @description Sends invoice when subscription charge fails if this is `true`
             * @default true
             */
            send_invoice_on_charge_failure: boolean;
            /**
             * @description Sends invoice when `POST /billing_templates/{id}/add_subscriber/` is called if this is `true`
             * @default false
             */
            send_invoice_on_add_subscriber: boolean;
            /**
             * @description Sends receipt when subscription charge succeeds if this is `true`
             * @default true
             */
            send_receipt: boolean;
        } & components["schemas"]["BaseModel"];
        /** @description City name */
        City: string;
        /** @description Record of a single customer of your business. Create one for each of your clients; you will be able to issue invoices/subscriptions for them later easily using `/billing_templates/` API.
         *
         *     Each BillingTemplateClient (there can be many attached to a single BillingTemplate) will bind a single Client to a BillingTemplate. */
        Client: components["schemas"]["BaseModel"] & components["schemas"]["ClientDetails"];
        /** @description Contains details about the client of a purchase or payment - the remote payer/fund recipient party. */
        ClientDetails: {
            email: components["schemas"]["Email"];
            phone?: components["schemas"]["Phone"];
            /** @description Name and surname of client */
            full_name?: string;
            /** @description Personal identification code of client */
            personal_code?: string;
            street_address?: components["schemas"]["StreetAddress"];
            country?: components["schemas"]["Country"];
            city?: components["schemas"]["City"];
            zip_code?: components["schemas"]["ZIPCode"];
            state?: components["schemas"]["State"];
            shipping_street_address?: components["schemas"]["StreetAddress"];
            shipping_country?: components["schemas"]["Country"];
            shipping_city?: components["schemas"]["City"];
            shipping_zip_code?: components["schemas"]["ZIPCode"];
            shipping_state?: components["schemas"]["State"];
            /** @description Email addresses to receive a carbon copy of all notification emails */
            cc?: components["schemas"]["Email"][];
            /** @description Email addresses to receive a blind carbon copy of all notification emails */
            bcc?: components["schemas"]["Email"][];
            /** @description Legal name of company */
            legal_name?: string;
            /** @description Company brand name */
            brand_name?: string;
            /** @description Registration number of company */
            registration_number?: string;
            /** @description Tax payer registration number */
            tax_number?: string;
            /**
             * @description List of delivery methods for invoices
             * @default [
             *       {
             *         "method": "email",
             *         "options": {}
             *       }
             *     ]
             */
            delivery_methods: {
                /**
                 * @description The method of invoice delivery
                 * @enum {string}
                 */
                method: "email" | "text_message";
                /** @description Additional options for the delivery method */
                options: {
                    /** @description Custom message for text message delivery */
                    custom_message?: string;
                };
            }[];
        } & components["schemas"]["BankAccountMixin"];
        ClientRecurringToken: components["schemas"]["BaseModel"] & {
            /** @description Payment method used to create this token, e.g. `card`. */
            readonly payment_method?: string;
            /** @description Description of this token, if available. For card payments, this field will contain the masked card number. */
            readonly description?: string;
        };
        /**
         * @description Balance data
         * @example {
         *       "ecommerce": [
         *         {
         *           "currency": "GBP",
         *           "gross_balance": 3232409,
         *           "balance": 3232409,
         *           "available_balance": 3185444,
         *           "reserved": 0,
         *           "pending_outgoing": 46965,
         *           "fee_sell": 0,
         *           "payout_gross_balance": 0,
         *           "payout_balance": 0,
         *           "available_payout_balance": 0,
         *           "pending_payouts": 0,
         *           "payout_overdraft": 0,
         *           "payout_fee_sell": 0
         *         },
         *         {
         *           "currency": "USD",
         *           "gross_balance": 3827891,
         *           "balance": 3827891,
         *           "available_balance": 3802744,
         *           "reserved": 0,
         *           "pending_outgoing": 25147,
         *           "fee_sell": 0,
         *           "payout_gross_balance": 0,
         *           "payout_balance": 0,
         *           "available_payout_balance": 0,
         *           "pending_payouts": 0,
         *           "payout_overdraft": 0,
         *           "payout_fee_sell": 0
         *         },
         *         {
         *           "currency": "EUR",
         *           "gross_balance": 7763713,
         *           "balance": 7763713,
         *           "available_balance": 7729281,
         *           "reserved": 0,
         *           "pending_outgoing": 34432,
         *           "fee_sell": 0,
         *           "payout_gross_balance": 0,
         *           "payout_balance": 0,
         *           "available_payout_balance": 0,
         *           "pending_payouts": 0,
         *           "payout_overdraft": 0,
         *           "payout_fee_sell": 0
         *         }
         *       ],
         *       "bank_accounts": [
         *         {
         *           "id": "9088acbc-54e5-4ff0-8b94-d08f855aa09c",
         *           "iban": "GB29NWBK60161331926819",
         *           "swift": "SPELGB11",
         *           "bank_account": "TEST",
         *           "bank_code": "SG0000000001",
         *           "real_bank_account": "GB29NWBK60161331926819",
         *           "real_bank_code": "SPELGB11",
         *           "currency": "GBP",
         *           "status": "active",
         *           "name": "",
         *           "reference": "SPELGB11",
         *           "available_balance": 9996003,
         *           "reserved_balance": 3385,
         *           "extended_ui": null,
         *           "fx_currencies": [
         *             "EUR",
         *             "USD",
         *             "GBP"
         *           ]
         *         },
         *         {
         *           "id": "d6f63e07-4954-42e0-a87c-45167bd2e401",
         *           "iban": "DE00SPEL00000000005882",
         *           "swift": "SPELDE66",
         *           "bank_account": "",
         *           "bank_code": "",
         *           "real_bank_account": "DE00SPEL00000000005882",
         *           "real_bank_code": "SPELDE66",
         *           "currency": "EUR",
         *           "status": "active",
         *           "name": "Account 1",
         *           "reference": null,
         *           "available_balance": 12567256,
         *           "reserved_balance": 0,
         *           "extended_ui": null,
         *           "fx_currencies": []
         *         }
         *       ],
         *       "payout_balances_enabled": {
         *         "EUR": false,
         *         "GBP": false,
         *         "USD": false
         *       }
         *     }
         */
        CompanyBalance: {
            /** @description Ecommerce data */
            ecommerce?: components["schemas"]["EcommerceItem"][];
            /** @description Bank account data */
            bank_accounts?: components["schemas"]["BankAccount"][];
            payout_balances_enabled?: {
                [key: string]: boolean;
            };
        };
        CompanyStatement: {
            /** @description Statement format, available formats: `csv`, `xlsx`. */
            format?: string;
            /**
             * Format: TZ database name
             * @description Timezone to localize statement-specific timestamps
             * @example Europe/Oslo
             */
            timezone?: string;
            /** @description Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode. */
            readonly is_test?: boolean;
            /**
             * Format: uuid
             * @description ID of the Company.
             */
            readonly company_uid?: string;
            /** @description Query parameters used to generate statement. */
            readonly query_string?: string;
            /** @description Status of statement generation e.g. `pending`, `processing`, `success`. */
            readonly status?: string;
            /** @description Download URL of a statement. */
            readonly download_url?: string;
            /** @description Date and time for the beginning of statement generation process. */
            readonly began_on?: components["schemas"]["UnixTimestamp"];
            /** @description Date and time for finishing the statement generation process. */
            readonly finished_on?: components["schemas"]["UnixTimestamp"];
            /** @description Object creation time */
            readonly created_on?: components["schemas"]["UnixTimestamp"];
            /** @description Object last modification time */
            readonly updated_on?: components["schemas"]["UnixTimestamp"];
            /** @description Statement request type */
            readonly type?: string;
            /**
             * Format: uuid
             * @description ID of a statement
             */
            readonly id?: string;
        };
        /**
         * Format: ISO 3166-1 alpha-2
         * @description Country code in the ISO 3166-1 alpha-2 format (e.g. 'GB')
         */
        Country: string;
        /**
         * Format: ISO 4217
         * @description Currency code in the ISO 4217 standard (e.g. 'EUR').  Default currency is `EUR`.
         */
        Currency: string;
        /** @description Ecommerce item */
        EcommerceItem: {
            currency?: components["schemas"]["Currency"];
            gross_balance?: components["schemas"]["MoneyAmount"];
            balance?: components["schemas"]["MoneyAmount"];
            available_balance?: components["schemas"]["MoneyAmount"];
            reserved?: components["schemas"]["MoneyAmount"];
            pending_outgoing?: components["schemas"]["MoneyAmount"];
            fee_sell?: components["schemas"]["MoneyAmount"];
            payout_gross_balance?: components["schemas"]["MoneyAmount"];
            payout_balance?: components["schemas"]["MoneyAmount"];
            available_payout_balance?: components["schemas"]["MoneyAmount"];
            pending_payouts?: components["schemas"]["MoneyAmount"];
            payout_overdraft?: components["schemas"]["MoneyAmount"];
            payout_fee_sell?: components["schemas"]["MoneyAmount"];
        };
        /**
         * Format: email
         * @description Email address
         */
        Email: string;
        /**
         * @description Available event types and when they are emitted:
         *
         *     `purchase.created`: Emitted when a Purchase is created. This happens as a result of POST /purchases/ request executed successfully or of any of the Billing API methods, including scheduled billing run by a BillingTemplate with is_subscription = true. Purchase.status will be == `created` in the received payload.
         *
         *     ---
         *
         *     `purchase.paid`: Emitted when a Purchase is paid for. Purchase.status will be == `paid`. Happens when a payform is submitted (for a Purchase having `skip_capture == false`) and a successful payment is done by the payer or in case of /capture/ or /charge/ API requests executed successfully.
         *
         *     ---
         *
         *     `purchase.payment_failure`: Emitted when payer submits a payment using the payform, but it doesn't complete successfully (e.g. because payer's account balance is insufficient). Purchase.status will be == `error`.
         *
         *     ---
         *
         *     `purchase.pending_execute`: Emitted when transaction execution takes longer than expected on the acquirer side. See `pending_execute` Purchase status. When transaction becomes finalized, a `purchase.paid`, `purchase.hold` or `purchase.payment_failed` callback will be emitted.
         *
         *     ---
         *
         *     `purchase.pending_charge`: Emitted when transaction execution takes longer than expected on the acquirer side. See `pending_charge` Purchase status. When transaction becomes finalized, a `purchase.paid` or `purchase.payment_failed` callback will be emitted.
         *
         *     ---
         *
         *     `purchase.cancelled`: Emitted once POST /purchases/{id}/cancel/ request succeeds. It won't be possible to pay for the related Purchase after that. Purchase.status will be == `cancelled`.
         *
         *     ---
         *
         *     `purchase.hold`: Emitted when a Purchase having `skip_capture == true` has its payform submitted and "payment" performed successfully. The specified amount of funds will be placed on hold. Purchase.status will be == `hold`.
         *
         *     ---
         *
         *     `purchase.captured`: Emitted when the POST /purchases/{id}/capture/ request for a Purchase that previously had the status of `hold` succeeds. Purchase.status will be == `paid`.
         *
         *     ---
         *
         *     `purchase.pending_capture`: Emitted when transaction execution takes longer than expected on the acquirer side. See `pending_capture` Purchase status. When transaction becomes finalized, a `purchase.captured` callback will be emitted.
         *
         *     ---
         *
         *     `purchase.released`: Emitted when the POST /purchases/{id}/release/ request for a Purchase that previously had the status of `hold` succeeds. Funds reserved will be released with no payment performed. Purchase.status will be == `released`.
         *
         *     ---
         *
         *     `purchase.pending_release`: Emitted when transaction execution takes longer than expected on the acquirer side. See `pending_release` Purchase status. When transaction becomes finalized, a `purchase.released` callback will be emitted.
         *
         *     ---
         *
         *     `purchase.preauthorized`: Emitted when preauthorization scenario (see description for the Purchase.skip_capture field) is executed successfully. Purchase will have a status of `preauthorized`.
         *
         *     ---
         *
         *     `purchase.recurring_token_deleted`: Emitted when the POST /purchases/{id}/delete_recurring_token/ request is executed successfully, deleting the recurring token associated with a Purchase. Purchase status will be the same as it were prior to this event.
         *
         *     ---
         *
         *     `purchase.pending_recurring_token_delete`: Emitted when token deletion takes longer than expected on the acquirer side. When operation is finalized, a `purchase.recurring_token_deleted` callback will be emitted.
         *
         *     ---
         *
         *     `purchase.subscription_charge_failure`: Emitted when an attempt to charge some Client's subscription-generated Purchase, using the token (e.g. card) they saved for their subscription, fails. Can only be emitted for a Purchase spawned from a BillingTemplate having is_subscription == true. Usually means the system can't charge the subscriber Client's card because e.g. their account balance is insufficient or card is expired, hence an invoice to be paid manually will be automatically mailed to them. Purchase.status in the returned payload will be == `sent`.
         *
         *     ---
         *
         *     `purchase.pending_refund`: Emitted when refund transaction execution takes longer than expected on the acquirer side. See `pending_refund` Purchase status. When refund becomes finalized, a `payment.refunded` callback will ne emitted.
         *
         *     ---
         *
         *     `payment.refunded`: Emitted when a Purchase is refunded (as a result of POST /purchases/{id}/capture/ request done successfully or action performed in company's frontoffice system). The returned data will be a Payment object generated as a result of this action. A link to the original Purchase (that will have a status of `refunded`) will be present in the `related_to` field of this Payment.
         *
         *     ---
         *
         *     `billing_template_client.subscription_billing_cancelled`: Emitted when a subscriber represented by this event's related BillingTemplateClient cancels their subscription using an email link available in the receipts he receives. The respective BillingTemplateClient will have its `status` set to `subscription_paused` as a result.
         *
         *     ---
         *
         *     `payout.pending`: Emitted when Payout execution has been initiated and is currently processing.
         *
         *     ---
         *
         *     `payout.failed`: Emitted when a Payout processing was completed with an error. Payout.status will be == `error`. Note that payouts can spend up to 3-5 days (depending on the payout provider) in processing after being initiated.
         *
         *     ---
         *
         *     `payout.success`: Emitted when a Payout is successfully processed. Payout.status will be == `success`. Note that payouts can spend up to 3-5 days (depending on the payout provider) in processing after being initiated.
         *
         *     ---
         *
         *     `payment.charged_back`: Emitted when a Payment is charged_back.
         *
         *     ---
         *
         *     `purchase.viewed`: Emitted when a Purchase is viewed.
         *
         *     ---
         *
         *     `purchase.settled`: Emitted when a Purchase is settled.
         *
         *     ---
         *
         *     `payout.created`: Emitted when a Payout is created.
         * @enum {string}
         */
        Event: "purchase.created" | "purchase.paid" | "purchase.payment_failure" | "purchase.pending_execute" | "purchase.pending_charge" | "purchase.cancelled" | "purchase.hold" | "purchase.captured" | "purchase.pending_capture" | "purchase.released" | "purchase.pending_release" | "purchase.preauthorized" | "purchase.pending_recurring_token_delete" | "purchase.recurring_token_deleted" | "purchase.subscription_charge_failure" | "purchase.pending_refund" | "payment.refunded" | "billing_template_client.subscription_billing_cancelled" | "payout.pending" | "payout.failed" | "payout.success" | "payment.charged_back" | "purchase.viewed" | "purchase.settled" | "payout.created";
        FeeSell: components["schemas"]["MoneyAmount"] & unknown;
        /** @description Read-only details of issuer company/brand, persisted for invoice display. */
        IssuerDetails: {
            /** @description Company website URL */
            readonly website?: components["schemas"]["URL"];
            readonly legal_street_address?: components["schemas"]["StreetAddress"];
            readonly legal_country?: components["schemas"]["Country"];
            readonly legal_city?: components["schemas"]["City"];
            readonly legal_zip_code?: components["schemas"]["ZIPCode"];
            readonly bank_accounts?: components["schemas"]["BankAccountMixin"][];
            /** @description Legal name of company */
            readonly legal_name?: string;
            /** @description Company brand name */
            readonly brand_name?: string;
            /** @description Registration number of company */
            readonly registration_number?: string;
            /** @description Tax payer registration number */
            readonly tax_number?: string;
        };
        /** @description Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY. */
        MoneyAmount: number;
        /** @description A record of a performed financial transaction. Can be generated e.g. as a result of refund operation. */
        Payment: {
            readonly client?: components["schemas"]["ClientDetails"];
            readonly payment?: components["schemas"]["PaymentDetails"];
            /** @description Payment method-specific, read-only, internal transaction data. Will contain information about all the transaction attempts, if available. */
            readonly transaction_data?: Record<string, never> | null;
            /** @description The object type and id this object is related to, if any. E.g. refund Payments are related to a specific Purchase, so this object will contain `type: purchase` and `id: <purchase's id>`. */
            readonly related_to?: {
                /** @description Object type identifier */
                readonly type?: string;
                /** Format: uuid */
                readonly id?: string;
            } | null;
            /** @description If an explicit invoice `reference` wasn't provided, this autogenerated value will be used as a reference instead. */
            readonly reference_generated?: string;
            /** @description Invoice reference. */
            readonly reference?: string;
            /**
             * Format: uuid
             * @description ID of an account this Payment is associated with.
             */
            readonly account_id?: string;
            /** Format: uuid */
            readonly company_id?: string;
            /** @description Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode. */
            readonly is_test?: boolean;
            /**
             * Format: uuid
             * @description ID of user who has created this object in the Billing UI, if applicable.
             */
            readonly user_id?: string | null;
            /**
             * Format: uuid
             * @description ID of the brand this Payment is associated with.
             */
            readonly brand_id?: string;
        } & components["schemas"]["BaseModel"];
        /** @description Details of an executed transaction. Read-only for `Purchase`s and `Payout`s. For an unpaid `Purchase`, this object will be `null`. */
        PaymentDetails: {
            /**
             * @description Denotes the direction of payment, e.g. for a paid Purchase, is granted to be `false`, `true` for payouts.
             * @default false
             */
            is_outgoing: boolean;
            /** @enum {string} */
            readonly payment_type?: "purchase" | "purchase_charge" | "payout" | "bank_payment" | "refund" | "custom";
            amount?: components["schemas"]["MoneyAmount"];
            currency?: components["schemas"]["Currency"];
            readonly net_amount?: components["schemas"]["MoneyAmount"];
            readonly fee_amount?: components["schemas"]["MoneyAmount"];
            readonly pending_amount?: components["schemas"]["MoneyAmount"];
            /** @default null */
            readonly pending_unfreeze_on: components["schemas"]["UnixTimestamp"] | null;
            description?: string;
            /** @description When the payment was accepted in (`is_outgoing == false`) or sent from (`is_outgoing == true`) the gateway system. */
            readonly paid_on?: components["schemas"]["UnixTimestamp"];
            /** @description If available, this field will report the date the payment was sent by the remote payer (`is_outgoing == false`) or when funds arrived to the remote beneficiary (`is_outgoing == true`). */
            readonly remote_paid_on?: components["schemas"]["UnixTimestamp"];
        };
        /**
         * @description Payment method used to execute the transaction.
         *
         *     - connectapi_billblend: Connectapi Billblend
         *     - connectapi_payadmit_apm: Connectapi Payadmit Apm
         *     - connectapi_pcb_apm: Connectapi Pcb Apm
         *     - connectapi_pmz_apm: Connectapi Pmz Apm
         *     - connectapi_pne_apm_redirect: Connectapi Pne Apm Redirect
         *     - connectapi_psf_apm: Connectapi Psf Apm
         *     - connectapi_zen_apm: Connectapi Zen Apm
         *     - gp_sepa: GP SEPA
         *     - hcpay: Hcpay
         *     - jcb: JCB payment card
         *     - maestro: Maestro payment card
         *     - mastercard: Mastercard payment card
         *     - payadmit: Payadmit
         *     - paycombat: Paycombat
         *     - pp: PP
         *     - pn_sepa: PN SEPA
         *     - pne_apm_redirect: Pne Apm Redirect
         *     - spell_katarun_redirect: Spell Katarun Redirect
         *     - unionpay: UnionPay payment card
         *     - unknown: Payment method could not be determinded
         *     - visa: Visa payment card
         *     - xpate_apple_pay: Apple Pay
         *     - xpate_google_pay: Xpate Google Pay
         *     - zen_apm_other: Zen Apm Other
         * @enum {string}
         */
        PaymentMethod: "connectapi_billblend" | "connectapi_payadmit_apm" | "connectapi_pcb_apm" | "connectapi_pmz_apm" | "connectapi_pne_apm_redirect" | "connectapi_psf_apm" | "connectapi_zen_apm" | "gp_sepa" | "hcpay" | "jcb" | "maestro" | "mastercard" | "payadmit" | "paycombat" | "pp" | "pn_sepa" | "pne_apm_redirect" | "spell_katarun_redirect" | "unionpay" | "unknown" | "visa" | "xpate_apple_pay" | "xpate_google_pay" | "zen_apm_other";
        /** @description Record of a single payout operation. Has a status attribute, e.g. can be initialized, error or success. */
        Payout: {
            payment: WithRequired<components["schemas"]["PaymentDetails"], "amount" | "currency">;
            client: WithRequired<components["schemas"]["ClientDetails"], "email">;
            /** @description Payment method-specific, read-only transaction data. Will contain information about all the transaction attempts and possible errors, if available. */
            readonly transaction_data?: {
                /** @description Payment method used if Payout was paid, blank string otherwise. */
                payment_method?: string;
                /** @description Extra data associated with selected payment method if Payout was paid, empty object otherwise. Dataset depends on payment method. E.g. for card payment methods like `visa` or `mastercard` it will contain properties `masked_pan: string`, `three_d_secure: boolean`, `expiry_month: int`, `expiry_year: int` and `cardholder_name: string`. */
                extra?: Record<string, never>;
                /** @description Country code (in the ISO 3166-1 alpha-2 format e.g. 'GB') where payment tool used originates (e.g. in case of card payments, the card issuing country). Will be blank if Payout was not paid or country could not be detected. */
                country?: string;
                /** @description Will contain information about all the payment attempts made and errors encountered, if any. */
                attempts?: {
                    /** @description If this attempt was successful or not. For `false`, `error` of this attempt will be not null. */
                    successful?: boolean;
                    /** @description Payment method used for this attempt. */
                    payment_method?: string;
                    /** @description Extra data associated with selected payment method. Dataset depends on payment method. E.g. for card payment methods like `visa` or `mastercard` it will contain properties `masked_pan: string`, `three_d_secure: boolean`, `expiry_month: int`, `expiry_year: int` and `cardholder_name: string`. */
                    extra?: Record<string, never>;
                    /** @description Country code (in the ISO 3166-1 alpha-2 format e.g. 'GB') where payment tool used originates (e.g. in case of card payments, the card issuing country). Will be blank if country could not be detected. */
                    country?: string;
                    /**
                     * Format: IP
                     * @description IP the paying client made this attempt from, if available.
                     */
                    client_ip?: string;
                    /** @description Time (if possible, fetched from the remot processing system) this attempt happened at. */
                    processing_time?: components["schemas"]["UnixTimestamp"];
                    /** @description Code and description of the error encountered. Not-null if `successful` parameter of this attempt is `false`. */
                    error?: {
                        /** @description Available error codes:
                         *
                         *     ---
                         *
                         *     `unknown_payment_method`: Unknown payment method
                         *
                         *     ---
                         *
                         *     `invalid_card_number`: Invalid card number
                         *
                         *     ---
                         *
                         *     `invalid_expires`: Invalid expires
                         *
                         *     ---
                         *
                         *     `no_matching_terminal`: No matching terminal
                         *
                         *     ---
                         *
                         *     `blacklisted_tx`: Blacklisted transaction: blocked (general)
                         *
                         *     ---
                         *
                         *     `timeout_3ds_enrollment_check`: 3DS enrollment check timeout
                         *
                         *     ---
                         *
                         *     `timeout_acquirer_status_check`: Timeout checking payment status with acquirer
                         *
                         *     ---
                         *
                         *     `validation_card_details_missing`: Card data field values are missing from request
                         *
                         *     ---
                         *
                         *     `validation_cvc_not_provided`: `cvc` field not provided
                         *
                         *     ---
                         *
                         *     `validation_cardholder_name_not_provided`: `cardholder_name` field not provided
                         *
                         *     ---
                         *
                         *     `validation_card_number_not_provided`: `card_number` field not provided
                         *
                         *     ---
                         *
                         *     `validation_expires_not_provided`: `expires` field not provided
                         *
                         *     ---
                         *
                         *     `validation_cvc_too_long`: `cvc` is too long
                         *
                         *     ---
                         *
                         *     `validation_cardholder_name_too_long`: `cardholder_name` is too long
                         *
                         *     ---
                         *
                         *     `validation_card_number_too_long`: `card_number` is too long
                         *
                         *     ---
                         *
                         *     `validation_expires_too_long`: `expires` is too long
                         *
                         *     ---
                         *
                         *     `3ds_authentication_failed`: 3DS authentication failed
                         *
                         *     ---
                         *
                         *     `validation_cvc_invalid`: `cvc` is invalid
                         *
                         *     ---
                         *
                         *     `validation_cardholder_name_invalid`: `cardholder_name` is too long or invalid
                         *
                         *     ---
                         *
                         *     `validation_card_number_invalid`: `card_number` is invalid
                         *
                         *     ---
                         *
                         *     `validation_expires_invalid`: `expires` is invalid
                         *
                         *     ---
                         *
                         *     `acquirer_connection_error`: Acquirer connection error
                         *
                         *     ---
                         *
                         *     `blacklisted_tx_issuing_country`: Blacklisted transaction: issuing country
                         *
                         *     ---
                         *
                         *     `s2s_not_supported`: Server-to-server flow not supported by processing
                         *
                         *     ---
                         *
                         *     `timeout`: Operation timeout
                         *
                         *     ---
                         *
                         *     `general_transaction_error`: Unrecognized transaction error
                         *
                         *     ---
                         *
                         *     `antifraud_general`: Decline, fraud
                         *
                         *     ---
                         *
                         *     `acquirer_internal_error`: Acquirer internal error
                         *
                         *     ---
                         *
                         *     `exceeds_frequency_limit`: Exceeds frequency limit
                         *
                         *     ---
                         *
                         *     `insufficient_funds`: Insufficient funds
                         *
                         *     ---
                         *
                         *     `purchase_already_paid_for`: Purchase is already paid for
                         *
                         *     ---
                         *
                         *     `issuer_not_available`: Issuer Not Available
                         *
                         *     ---
                         *
                         *     `do_not_honour`: Do not honour (the transaction was declined by the Issuer without definition or reason).
                         *
                         *     ---
                         *
                         *     `exceeds_withdrawal_limit`: Exceeds withdrawal limit
                         *
                         *     ---
                         *
                         *     `exceeded_account_limit`: Exceeded account limit
                         *
                         *     ---
                         *
                         *     `expired_card`: Expired card
                         *
                         *     ---
                         *
                         *     `blacklisted_tx_risk_score`: Blacklisted transaction: risk score
                         *
                         *     ---
                         *
                         *     `transaction_not_supported_or_not_valid_for_card`: The transaction request presented is not supported or is not valid for the card number presented.
                         *
                         *     ---
                         *
                         *     `exceeded_acquirer_refund_amount`: Exceeded refundable amount defined by acquirer
                         *
                         *     ---
                         *
                         *     `transaction_not_permitted_on_terminal`: Transaction not permitted on terminal (this card does not support the type of transaction requested).
                         *
                         *     ---
                         *
                         *     `acquirer_configuration_error`: Acquirer configuration error
                         *
                         *     ---
                         *
                         *     `transaction_not_permitted_to_cardholder`: Transaction not permitted to cardholder
                         *
                         *     ---
                         *
                         *     `invalid_issuer_number`: No such issuer (the Issuer number is not valid).
                         *
                         *     ---
                         *
                         *     `restricted_card`: Restricted card
                         *
                         *     ---
                         *
                         *     `merchant_response_timeout`: Timeout of merchant response exceeded
                         *
                         *     ---
                         *
                         *     `reconcile_error`: Reconcilation error
                         *
                         *     ---
                         *
                         *     `lost_card`: Lost card
                         *
                         *     ---
                         *
                         *     `stolen_card`: Stolen card
                         *
                         *     ---
                         *
                         *     `invalid_amount`: Invalid amount
                         *
                         *     ---
                         *
                         *     `re_enter_transaction`: Re enter transaction
                         *
                         *     ---
                         *
                         *     `security_violation`: Security violation
                         *
                         *     ---
                         *
                         *     `partial_forbidden`: Intervene, bank approval required for partial amount
                         *
                         *     ---
                         *
                         *     `suspected_fraud`: Decline, suspected fraud
                         *
                         *     ---
                         *
                         *     `acquirer_routing_error`: Acquirer routing error
                         *
                         *     ---
                         *
                         *     `payment_rejected_other_reason`: Payment rejected (other reason)
                         *
                         *     ---
                         *
                         *     `authorization_failed`: Payment authorization failed
                         *
                         *     ---
                         *
                         *     `acquirer_error_cs`: Internal acquirer error. Please, contact support.
                         *
                         *     ---
                         *
                         *     `decline_irregular_transaction_pattern`: Declined by acquirer - irregular transaction pattern, please contact support
                         *
                         *     ---
                         *
                         *     `invalid_card_data`: Invalid card data provided
                         *
                         *     ---
                         *
                         *     `exceeded_terminal_limit`: Exceeded terminal limit
                         *
                         *     ---
                         *
                         *     `recurring_token_expired`: recurring token expired
                         *
                         *     ---
                         *
                         *     `soft_decline_contact_support`: Soft Decline - Please contact support for manual settlement of this purchase
                         *
                         *     ---
                         *
                         *     `payment_method_details_missing`: Missing payment_method_details
                         *
                         *     ---
                         *
                         *     `validation_phone_invalid`: `phone` is invalid
                         *
                         *     ---
                         *
                         *     `validation_address_invalid`: address is invalid */
                        code?: string;
                        /** @description Verbose name and explanation of this error. */
                        message?: string;
                    } | null;
                }[];
            };
            /** @description If you don't provide an invoice `reference` yourself, this autogenerated value will be used as a reference instead. */
            readonly reference_generated?: string;
            /** @description Payout reference. */
            reference?: string;
            status?: components["schemas"]["PayoutStatus"];
            /** @description History of status changes, latest last. */
            readonly status_history?: {
                status?: components["schemas"]["PayoutStatus"];
                timestamp?: components["schemas"]["UnixTimestamp"];
            }[];
            /** @description Name of payout sender. */
            sender_name?: string;
            /** @description Recipient's card's registration country. Country code in the ISO 3166-1 alpha-2 format (e.g. `GB`). */
            readonly recipient_card_country?: string;
            /** @description Recipient's card's brand, e.g. `visa` or `mastercard`. */
            readonly recipient_card_brand?: string;
            /** @description An optional whitelist of payment methods availble for this Payout. Use this field if you want to restrict your payer to pay using only one or several specific methods. */
            payout_method_whitelist?: string[];
            /** @description URL that must be used for payout execution. See details in description. */
            readonly execution_url?: string;
            /**
             * Format: uuid
             * @description ID of the brand to create this Payout for. You can copy it down in the API section, see the "specify the ID of the Brand" link in answer to "How to setup payments on website or in mobile app?".
             */
            brand_id: string;
            /** Format: uuid */
            readonly company_id?: string;
            /** @description Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode. */
            readonly is_test?: boolean;
            /**
             * Format: uuid
             * @description ID of user who has created this object in the Billing UI, if applicable.
             */
            readonly user_id?: string | null;
        } & components["schemas"]["BaseModel"];
        /**
         * @description `Payout` status. Can have the following values:
         *
         *     `initialized`: `Payout` was created, but not executed. Initial status to new `Payout`s.
         *
         *     ---
         *
         *     `pending`: `Payout`'s execution is currently pending
         *
         *     ---
         *
         *     `error`: An error has occurred during the execution. Execution can be attempted again.
         *
         *     ---
         *
         *     `success`: `Payout` was executed successfully.
         * @default initialized
         * @enum {string}
         */
        PayoutStatus: "initialized" | "pending" | "error" | "success";
        /** @enum {string} */
        PeriodUnits: "days" | "weeks" | "months";
        /**
         * Format: phone
         * @description Phone number in the `<country_code> <number>` format
         * @example +44 45643564564
         */
        Phone: string;
        Product: {
            /** @description Product name */
            name: string;
            /**
             * Format: float
             * @description Quantity of these products in invoice
             * @default 1
             */
            quantity: string;
            /** @description Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY. You can use this field or `total_override` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field. */
            price: components["schemas"]["MoneyAmount"];
            /**
             * @description Total discount per this product in invoice
             * @default 0
             */
            discount: components["schemas"]["MoneyAmount"];
            /**
             * Format: float
             * @description Percent of tax added to the price of this product
             * @default 0
             */
            tax_percent: string;
            /** @description Product category */
            category?: string;
        };
        /**
         * @description PEM-encoded RSA public key for authenticating webhook or callback payloads
         * @example -----BEGIN PUBLIC KEY-----
         *     MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEA6gLlBKxCB5dxPJbinCzl
         *     hOfKSgQtOWQQBxmnWIkEVUbqhpnqr3xNYiAvDyMUxYUwuzN44eHO+mR9MZWcSx3c
         *     bXmKa3gsOzR6GdcOxMGaVxvfje+fujCAlCtO1BP+A9/FS3KcPgCYG1wtAPwA5IAf
         *     HylL3TsUVIJQFBgiBr6N4Bgapr9eloaFfeYIBRsXmxPKAMJivqxYpLh0V3N4ZFd5
         *     TGqSEAa4b1ULDr6p0sB2L3QikTdsF0zp03zNceKA6fXDOzD0xWtg9buXvyKwePK4
         *     M2kcnWBNfsWghrdg0fG3O9bmkaS1oEXydrmJfuiI8h6a64J/1nzooi2yLC9D6Ta0
         *     S63bbuAHymnQtiNuV7Ixp6IoTGFaS88aTiHaP8rdyWV8JTDFx0qeDzyaGWiYGwEF
         *     mj/buHCEcRhoajbGkPhYA4YEdn4jy1wZhEr2OMdBPM7mPPI0Hy3hcNJVMVVlrpHe
         *     IltQATpjlNaJMlRPjbcaiW7dsO3BuF9ZOMGksSOnyYm/AgMBAAE=
         *     -----END PUBLIC KEY-----
         */
        PublicKey: string;
        /** @description Record of a single purchase operation, either a transaction originating from e-commerce integration or invoice sent. Has a status attribute, e.g. can be `created`, `paid` or `refunded`. */
        Purchase: {
            /** @description Either this or `.client_id` is required. */
            client: components["schemas"]["ClientDetails"];
            purchase: components["schemas"]["PurchaseDetails"];
            readonly payment?: components["schemas"]["PaymentDetails"] | null;
            readonly issuer_details?: components["schemas"]["IssuerDetails"];
            /** @description Payment method-specific, read-only transaction data. Will contain information about all the transaction attempts and possible errors, if available. */
            readonly transaction_data?: {
                /** @description Payment method used if Purchase was paid, blank string otherwise. */
                payment_method?: string;
                /** @description Extra data associated with selected payment method if Purchase was paid, empty object otherwise. Dataset depends on payment method. E.g. for card payment methods like `visa` or `mastercard` it will contain properties `masked_pan: string`, `three_d_secure: boolean`, `expiry_month: int`, `expiry_year: int` and `cardholder_name: string`. */
                extra?: Record<string, never>;
                /** @description Country code (in the ISO 3166-1 alpha-2 format e.g. 'GB') where payment tool used originates (e.g. in case of card payments, the card issuing country). Will be blank if Purchase was not paid or country could not be detected. */
                country?: string;
                /** @description Will contain information about all the payment attempts made and errors encountered, if any. */
                attempts?: {
                    /**
                     * @description Type of action attempted
                     * @enum {string}
                     */
                    type?: "execute" | "authorize" | "release" | "capture" | "recurring_execute" | "delete_recurring_token" | "refund";
                    /** @description If this attempt was successful or not. For `false`, `error` of this attempt will be not null. */
                    successful?: boolean;
                    /** @description Payment method used for this attempt. */
                    payment_method?: string;
                    /** @description Extra data associated with selected payment method. Dataset depends on payment method. E.g. for card payment methods like `visa` or `mastercard` it will contain properties `masked_pan: string`, `three_d_secure: boolean`, `expiry_month: int`, `expiry_year: int` and `cardholder_name: string`. */
                    extra?: Record<string, never>;
                    /** @description Country code (in the ISO 3166-1 alpha-2 format e.g. 'GB') where payment tool used originates (e.g. in case of card payments, the card issuing country). Will be blank if country could not be detected. */
                    country?: string;
                    /**
                     * Format: IP
                     * @description IP the paying client made this attempt from, if available.
                     */
                    client_ip?: string;
                    /** @description Time (if possible, fetched from the remot processing system) this attempt happened at. */
                    processing_time?: components["schemas"]["UnixTimestamp"];
                    /** @description Code and description of the error encountered. Not-null if `successful` parameter of this attempt is `false`. */
                    error?: {
                        /** @description Available error codes:
                         *
                         *     ---
                         *
                         *     `unknown_payment_method`: Unknown payment method
                         *
                         *     ---
                         *
                         *     `invalid_card_number`: Invalid card number
                         *
                         *     ---
                         *
                         *     `invalid_expires`: Invalid expires
                         *
                         *     ---
                         *
                         *     `no_matching_terminal`: No matching terminal
                         *
                         *     ---
                         *
                         *     `blacklisted_tx`: Blacklisted transaction: blocked (general)
                         *
                         *     ---
                         *
                         *     `timeout_3ds_enrollment_check`: 3DS enrollment check timeout
                         *
                         *     ---
                         *
                         *     `timeout_acquirer_status_check`: Timeout checking payment status with acquirer
                         *
                         *     ---
                         *
                         *     `validation_card_details_missing`: Card data field values are missing from request
                         *
                         *     ---
                         *
                         *     `validation_cvc_not_provided`: `cvc` field not provided
                         *
                         *     ---
                         *
                         *     `validation_cardholder_name_not_provided`: `cardholder_name` field not provided
                         *
                         *     ---
                         *
                         *     `validation_card_number_not_provided`: `card_number` field not provided
                         *
                         *     ---
                         *
                         *     `validation_expires_not_provided`: `expires` field not provided
                         *
                         *     ---
                         *
                         *     `validation_cvc_too_long`: `cvc` is too long
                         *
                         *     ---
                         *
                         *     `validation_cardholder_name_too_long`: `cardholder_name` is too long
                         *
                         *     ---
                         *
                         *     `validation_card_number_too_long`: `card_number` is too long
                         *
                         *     ---
                         *
                         *     `validation_expires_too_long`: `expires` is too long
                         *
                         *     ---
                         *
                         *     `3ds_authentication_failed`: 3DS authentication failed
                         *
                         *     ---
                         *
                         *     `validation_cvc_invalid`: `cvc` is invalid
                         *
                         *     ---
                         *
                         *     `validation_cardholder_name_invalid`: `cardholder_name` is too long or invalid
                         *
                         *     ---
                         *
                         *     `validation_card_number_invalid`: `card_number` is invalid
                         *
                         *     ---
                         *
                         *     `validation_expires_invalid`: `expires` is invalid
                         *
                         *     ---
                         *
                         *     `acquirer_connection_error`: Acquirer connection error
                         *
                         *     ---
                         *
                         *     `blacklisted_tx_issuing_country`: Blacklisted transaction: issuing country
                         *
                         *     ---
                         *
                         *     `s2s_not_supported`: Server-to-server flow not supported by processing
                         *
                         *     ---
                         *
                         *     `timeout`: Operation timeout
                         *
                         *     ---
                         *
                         *     `general_transaction_error`: Unrecognized transaction error
                         *
                         *     ---
                         *
                         *     `antifraud_general`: Decline, fraud
                         *
                         *     ---
                         *
                         *     `acquirer_internal_error`: Acquirer internal error
                         *
                         *     ---
                         *
                         *     `exceeds_frequency_limit`: Exceeds frequency limit
                         *
                         *     ---
                         *
                         *     `insufficient_funds`: Insufficient funds
                         *
                         *     ---
                         *
                         *     `purchase_already_paid_for`: Purchase is already paid for
                         *
                         *     ---
                         *
                         *     `issuer_not_available`: Issuer Not Available
                         *
                         *     ---
                         *
                         *     `do_not_honour`: Do not honour (the transaction was declined by the Issuer without definition or reason).
                         *
                         *     ---
                         *
                         *     `exceeds_withdrawal_limit`: Exceeds withdrawal limit
                         *
                         *     ---
                         *
                         *     `exceeded_account_limit`: Exceeded account limit
                         *
                         *     ---
                         *
                         *     `expired_card`: Expired card
                         *
                         *     ---
                         *
                         *     `blacklisted_tx_risk_score`: Blacklisted transaction: risk score
                         *
                         *     ---
                         *
                         *     `transaction_not_supported_or_not_valid_for_card`: The transaction request presented is not supported or is not valid for the card number presented.
                         *
                         *     ---
                         *
                         *     `exceeded_acquirer_refund_amount`: Exceeded refundable amount defined by acquirer
                         *
                         *     ---
                         *
                         *     `transaction_not_permitted_on_terminal`: Transaction not permitted on terminal (this card does not support the type of transaction requested).
                         *
                         *     ---
                         *
                         *     `acquirer_configuration_error`: Acquirer configuration error
                         *
                         *     ---
                         *
                         *     `transaction_not_permitted_to_cardholder`: Transaction not permitted to cardholder
                         *
                         *     ---
                         *
                         *     `invalid_issuer_number`: No such issuer (the Issuer number is not valid).
                         *
                         *     ---
                         *
                         *     `restricted_card`: Restricted card
                         *
                         *     ---
                         *
                         *     `merchant_response_timeout`: Timeout of merchant response exceeded
                         *
                         *     ---
                         *
                         *     `reconcile_error`: Reconcilation error
                         *
                         *     ---
                         *
                         *     `lost_card`: Lost card
                         *
                         *     ---
                         *
                         *     `stolen_card`: Stolen card
                         *
                         *     ---
                         *
                         *     `invalid_amount`: Invalid amount
                         *
                         *     ---
                         *
                         *     `re_enter_transaction`: Re enter transaction
                         *
                         *     ---
                         *
                         *     `security_violation`: Security violation
                         *
                         *     ---
                         *
                         *     `partial_forbidden`: Intervene, bank approval required for partial amount
                         *
                         *     ---
                         *
                         *     `suspected_fraud`: Decline, suspected fraud
                         *
                         *     ---
                         *
                         *     `acquirer_routing_error`: Acquirer routing error
                         *
                         *     ---
                         *
                         *     `payment_rejected_other_reason`: Payment rejected (other reason)
                         *
                         *     ---
                         *
                         *     `authorization_failed`: Payment authorization failed
                         *
                         *     ---
                         *
                         *     `acquirer_error_cs`: Internal acquirer error. Please, contact support.
                         *
                         *     ---
                         *
                         *     `decline_irregular_transaction_pattern`: Declined by acquirer - irregular transaction pattern, please contact support
                         *
                         *     ---
                         *
                         *     `invalid_card_data`: Invalid card data provided
                         *
                         *     ---
                         *
                         *     `exceeded_terminal_limit`: Exceeded terminal limit
                         *
                         *     ---
                         *
                         *     `recurring_token_expired`: recurring token expired
                         *
                         *     ---
                         *
                         *     `soft_decline_contact_support`: Soft Decline - Please contact support for manual settlement of this purchase
                         *
                         *     ---
                         *
                         *     `payment_method_details_missing`: Missing payment_method_details
                         *
                         *     ---
                         *
                         *     `validation_phone_invalid`: `phone` is invalid
                         *
                         *     ---
                         *
                         *     `validation_address_invalid`: address is invalid */
                        code?: string;
                        /** @description Verbose name and explanation of this error. */
                        message?: string;
                    } | null;
                }[];
            };
            status?: components["schemas"]["PurchaseStatus"];
            /** @description History of status changes, latest last. Might contain entry about a related object, e.g. status change to `refunded` will contain a reference to the refund Payment. */
            readonly status_history?: {
                status?: components["schemas"]["PurchaseStatus"];
                timestamp?: components["schemas"]["UnixTimestamp"];
                related_object?: {
                    type?: string;
                    /** Format: uuid */
                    id?: string;
                } | null;
            }[];
            /** @description Time the payment form or invoice page was first viewed on */
            readonly viewed_on?: components["schemas"]["UnixTimestamp"] | null;
            /** Format: uuid */
            readonly company_id?: string;
            /** @description Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode. */
            readonly is_test?: boolean;
            /**
             * Format: uuid
             * @description ID of user who has created this object in the Billing UI, if applicable.
             */
            readonly user_id?: string | null;
            /**
             * Format: uuid
             * @description ID of the brand to create this Purchase for. You can copy it down in the API section, see the "specify the ID of the Brand" link in answer to "How to setup payments on website or in mobile app?".
             */
            brand_id: string;
            /**
             * Format: uuid
             * @description ID of a BillingTemplate that has spawned this Purchase, if any.
             */
            readonly billing_template_id?: string | null;
            /**
             * Format: uuid
             * @description ID of a Client object used to initialize ClientDetails (`.client`) of this Purchase. Either this field or specifying `.client` object is required (you can only specify a value for one of these fields). All `ClientDetails` fields from the Client will be copied to `.client` object. Note that editing Client object won't change the respective fields in already created Purchases.
             *
             *     If you specify this field and your client saves a `recurring_token` (for instance, by saving their card), the respective ClientRecurringToken will be created. See the `/clients/{id}/recurring_tokens/` endpoint.
             * @default null
             */
            client_id: string | null;
            /**
             * @description Whether to send receipt email for this Purchase when it's paid.
             * @default false
             */
            send_receipt: boolean;
            /** @description Indicates whether a recurring token (e.g. for card payments - card token) was saved for this Purchase. If this is `true`, the `id` of this Purchase can be used as a `recurring_token` in `POST /purchases/{id}/charge/`, enabling you to pay for that Purchase using the same method (same card for card payments) that this one was paid with. */
            readonly is_recurring_token?: boolean;
            /**
             * Format: uuid
             * @description ID of a recurring token (Purchase having `is_recurring_token == true`) that was used to pay this Purchase, if any.
             */
            readonly recurring_token?: string | null;
            /**
             * @description Card payment-specific: if set to true, only authorize the payment (place funds on hold) when payer enters his card data and pays. This option requires a `POST /capture/` or `POST /release/` later on.
             *
             *     You can use the preauthorization feature if you set this parameter to true and make the Purchase with `purchase.total == 0` (this can be achieved by providing a list of `purchase.products` with a total `price` of 0, or simply overriding the total using `purchase.total_override` to 0). The resulting Purchase can only be "paid" by the client (only cardholder data verification will happen, without a financial transaction) by card and will enforce saving the client's card. When this happens, the Purchase will have `status` of `preauthorized` and the `purchase.preauthorized` webhook callbacks will be emitted.
             *
             *     Trying to use skip_capture (or preauthorization) without any payment methods that support the respective actions (this can be a result of `payment_method_whitelist` field being used) will result in an error on Purchase creation request step. Please check the `GET /payment_methods/` response for your desired Purchase parameters and/or consult with your account manager.
             * @default false
             */
            skip_capture: boolean;
            /**
             * @description If the used payment method supports recurring payment functionality, forces the customer's payment credentials to be saved for possible later recurring payments, without giving the customer a choice in the matter.
             * @default false
             */
            force_recurring: boolean;
            /** @description If you don't provide an invoice `reference` yourself, this autogenerated value will be used as a reference instead. */
            readonly reference_generated?: string;
            /** @description Invoice reference. */
            reference?: string;
            /** @description Value for 'Invoice issued' field. Display-only, does not get validated. If not provided, will be generated as the current date in `purchase.timezone` at the moment of Purchase's creation. */
            issued?: components["schemas"]["Timestamp"] | null;
            /** @description When the payment is due for this Purchase. The default behaviour is to still allow payment once this moment passes. To change that, set `purchase.due_strict` to true. */
            due?: components["schemas"]["UnixTimestamp"] | null;
            /**
             * @description Specifies, if the purchase can be refunded fully and partially, only fully, partially or not at all.
             * @enum {string}
             */
            readonly refund_availability?: "all" | "full_only" | "partial_only" | "pis_all" | "pis_partial" | "none";
            readonly refundable_amount?: components["schemas"]["MoneyAmount"];
            /** @description This object is present when automatic currency conversion has occurred upon creation of the purchase. Purchase's original currency was changed and its original amount was converted using the exchange rate shown here. */
            readonly currency_conversion?: {
                /** @description Currency this purchase was initially created with */
                readonly original_currency?: string;
                /** @description Amount this purchase was initially created with */
                readonly original_amount?: number;
                /** @description Exchanged rate that was used for currency conversion. Original amount was multiplied by this number to calculate the new purchase amount. */
                readonly exchange_rate?: number;
            } | null;
            /** @description An optional whitelist of payment methods availble for this purchase. Use this field if you want to restrict your payer to pay using only one or several specific methods.
             *
             *     Using this field and at the same time trying to use specific capabilities of a Purchase (e.g. `skip_capture` or charging it using a saved card token using `POST /purchases/{id}/charge/`) can cause a situation when there are no payment methods available for paying this Purchase. This will cause a validation error on Purchase creation. Please check the `GET /payment_methods/` response for your desired Purchase parameters and/or consult with your account manager. */
            payment_method_whitelist?: string[];
            /** @description When Purchase is paid for successfully, your customer will be taken to this link. Otherwise a standard screen will be displayed. */
            success_redirect?: components["schemas"]["URL"];
            /** @description If there's a payment failure for this Purchase, your customer will be taken to this link. Otherwise a standard screen will be displayed. */
            failure_redirect?: components["schemas"]["URL"];
            /** @description If you provide this link, customer will have an option to go to it instead of making payment (a button with 'Return to seller' text will be displayed). Can't contain any of the following symbols: `<>'"` .
             *
             *     Be aware that this does not cancel the payment (e.g. does not do the equivalent of doing the `POST /purchases/{id}/cancel/` request); the client will still be able to press 'Back' in the browser and perform the payment. */
            cancel_redirect?: components["schemas"]["URL"];
            /** @description When Purchase is paid for successfully, the `success_callback` URL will receive a POST request with the Purchase object's data in body. */
            success_callback?: components["schemas"]["URL"];
            /** @description Identification of software (e.g. an ecommerce module and version) used to create this purchase, if any. */
            creator_agent?: string;
            /**
             * @description Platform this Purchase was created on.
             * @enum {string}
             */
            platform?: "web" | "api" | "ios" | "android" | "macos" | "windows";
            /**
             * @description Defines which gateway product was used to create this Purchase.
             * @enum {string}
             */
            readonly product?: "purchases" | "billing_invoices" | "billing_subscriptions" | "billing_subscriptions_invoice";
            /**
             * Format: IP
             * @description IP the Purchase was created from.
             */
            readonly created_from_ip?: string;
            /** @description URL you will be able to access invoice for this Purchase at, if applicable */
            readonly invoice_url?: components["schemas"]["URL"] | null;
            /** @description URL you will be able to access the checkout for this Purchase at, if payment for it is possible. When building integrations, redirect the customer to this URL once purchase is created.
             *
             *     You can add the `preferred` query arg to the `checkout_url` in order to force redirect the client straight to the checkout for a specific payment method (`?preferred={payment_method}`, where `{payment_method}` is the payment method name as returned by `GET /payment_methods/`). If this method redirects the client further to a different system and no customer data entry is needed on gateway's checkout page, your payer will be taken straight to that page (not seeing the gateway's checkout UI); otherwise, he will see the payment method entry UI on the gateway checkout page. */
            readonly checkout_url?: components["schemas"]["URL"];
            /** @description URL that can be used for Direct Post integration.
             *
             *     This functionality is activated for each merchant account individually. Please consult with your account manager if you wish to use it.
             *
             *     Will be null if payment for purchase is not possible, `purchase.request_client_details` isn't empty or success_redirect/failure_redirect are not provided - these all break the usual direct post flow.
             *
             *     To leverage Direct Post checkout, create a `<form>` having `method="POST" action="<direct_post_url value>"` and include the following inputs:
             *
             *     `cardholder_name: text, Latin letters only (space and apostrophe (`'`), dot (`.`), dash (`-`) symbols are also allowed), max 30 chars`
             *
             *     ---
             *
             *     `card_number: text, digits only, no whitespace, max 19 chars`
             *
             *     ---
             *
             *     `expires: text in 'MM/YY' format, digits and a slash only /^\d{2}\/\d{2}$/, max 5 chars`
             *
             *     ---
             *
             *     `cvc: numeric string of 3 or 4 digits`
             *
             *     ---
             *
             *     `remember_card: checkbox with value="on" (the default when omitting value attribute of a checkbox input)`
             *
             *     Ensure the validation as listed above! Validation errors will be treated as payment failures. Obviously, you can style this form to fit in with the rest of your website.
             *
             *     When your payer submits this form (don't forget a `<button>` or `<input type="submit">`), he will POST the data directly to the gateway system. There, with minimal interaction with gateway's interface, payment will be processed. In the process, your customer might get redirected to authenticate against 3D Secure system of his card issuer bank (this depends on settings of his card and your account). After that, payer will be taken to `success_redirect` or `failure_redirect` depending on the payment result (as in the usual payment flow).
             *
             *     Be aware, though, that while not having to process card data allows you not to comply with the entirety of PCI DSS SAQ D requirements, having sensitive cardholder data entry form on your website does raise your PCI DSS scope to SAQ A-EP. Contact your account manager to receive advisory and assistance for this integration method. */
            readonly direct_post_url?: components["schemas"]["URL"] | null;
            /** @description True if a purchase was manually marked as paid. */
            readonly marked_as_paid?: boolean;
            /** @description ID of corresponding order. */
            readonly order_id?: string;
            /** @description Array of IDs of related Upsell campaigns. */
            upsell_campaigns?: string[];
            /**
             * Format: uuid
             * @description ID of Referral campaign.
             */
            referral_campaign_id?: string | null;
            /** @description Referral code used with purchase. */
            readonly referral_code?: string;
            /** @description Referral code created by purchase. */
            readonly referral_code_generated?: string;
            /** @description Referral code detailed information for purchase. */
            readonly referral_code_details?: {
                /**
                 * Format: uuid
                 * @description Referral campaign ID.
                 */
                readonly campaign_id?: string;
                /**
                 * @description Reward type of applied Referral code.
                 * @enum {string}
                 */
                readonly reward_type?: "gift" | "discount" | "money";
                readonly discount_amount?: components["schemas"]["MoneyAmount"];
                /**
                 * Format: float
                 * @description Discount percent of applied Referral code
                 */
                readonly discount_percent?: number;
            };
            /** @description Retain level detailed information for purchase. */
            readonly retain_level_details?: {
                /**
                 * Format: uuid
                 * @description Retain campaign ID.
                 */
                readonly campaign_id?: string;
                readonly discount_amount?: components["schemas"]["MoneyAmount"];
                /**
                 * Format: float
                 * @description Discount percent of applied Retain level.
                 */
                readonly discount_percent?: number;
            };
        } & components["schemas"]["BaseModel"];
        /** @description Core information about the Purchase, including the products, total, currency and invoice fields. If you're using invoicing via `/billing/` or `/billing_templates/`, this object will be copied 1:1 from BillingTemplate you specify to the resulting Purchases (also to subscription Purchases). */
        PurchaseDetails: {
            currency?: components["schemas"]["Currency"];
            /** @description Line items of the invoice. In case of a transaction with no invoice sent, specify a single Product forming the cost of transaction. */
            products: components["schemas"]["Product"][];
            readonly total?: components["schemas"]["MoneyAmount"];
            /**
             * Format: ISO 639-1
             * @description Language code in the ISO 639-1 format (e.g. 'en'). Supported values: `az`, `de`, `en`, `en-GB`, `es`, `et`, `fr`, `it`, `lt`, `lv`, `pt`, `ru`, `tr`, `uk`.
             * @default Default value is controlled in Company -> Brand section of merchant portal separately per each Brand used (default value, if no changes are made, is `en`). Brand to be used with corresponding Purchase/BillingTemplate specified using brand_id.
             */
            language: string;
            notes?: string;
            /** @default 0 */
            debt: components["schemas"]["MoneyAmount"];
            /** @default null */
            subtotal_override: components["schemas"]["MoneyAmount"] | null;
            /** @default null */
            total_tax_override: components["schemas"]["MoneyAmount"] | null;
            /** @default null */
            total_discount_override: components["schemas"]["MoneyAmount"] | null;
            /** @default null */
            total_override: components["schemas"]["MoneyAmount"] | null;
            /**
             * @description ClientDetails fields to request from the client before the payment. If a value is passed for a field in ClientDetails, it will be automatically removed from this list.
             * @default []
             */
            request_client_details: ("email" | "phone" | "full_name" | "personal_code" | "brand_name" | "legal_name" | "registration_number" | "tax_number" | "bank_account" | "bank_code" | "billing_address" | "shipping_address")[];
            /**
             * Format: TZ database name
             * @description Timezone to localize invoice-specific timestamps in, e.g. to display a concrete date for a `due` timestamp on the invoice.
             * @example Europe/Oslo
             */
            timezone?: string;
            /**
             * @description Whether to permit payments when Purchase's `due` has passed. By default those are permitted (and status will be set to `overdue` once `due` moment is passed). If this is set to `true`, it won't be possible to pay for an overdue invoice, and when `due` is passed the Purchase's status will be set to `expired`.
             * @default false
             */
            due_strict: boolean;
            /** @description An optional message to display to your customer in invoice email, e.g. "Your invoice for June". */
            readonly email_message?: string;
        };
        /**
         * @description Purchase status. Can have the following values:
         *
         *     `created`: Purchase was created using POST /purchases/ or Billing API capabilities.
         *
         *     ---
         *
         *     `sent`: Invoice for this purchase was sent over email using Billing API capabilities.
         *
         *     ---
         *
         *     `viewed`: The client has viewed the payform and/or invoice details for this purchase.
         *
         *     ---
         *
         *     `error`: There was a failed payment attempt for this purchase because of a problem with customer's payment instrument (e.g. low account balance). You can analyze the `.transaction_data` to get information on reason of the failure.
         *
         *     ---
         *
         *     `cancelled`: Purchase was cancelled using the `POST /purchases/{id}/cancel/` endpoint; payment for it is not possible anymore.
         *
         *     ---
         *
         *     `overdue`: Purchase is past its' `.due`, but payment for it is still possible (unless e.g. POST /purchases/{id}/cancel/ is used).
         *
         *     ---
         *
         *     `expired`: Purchase is past its' `.due` and payment for it isn't possible anymore (as a result of `purchase.due_strict` having been set to `true`). It’s still possible to have a `paid` status after `expired` if the transaction was initiated before `expired` and the acquirer returned the successful status with delay.
         *
         *     ---
         *
         *     `hold`: Funds are on hold for this Purchase (`.skip_capture: true` was used). You can now run `POST /capture/` or `POST /release/` for this payment to capture the payment or return funds to the client, respectively.
         *
         *     ---
         *
         *     `released`: This Purchase previously had `hold` status, but funds have since been released and returned to the customer's card.
         *
         *     ---
         *
         *     `pending_release`: release of funds for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/release/` operation when it takes longer than expected to process on the acquirer side.
         *
         *     ---
         *
         *     `pending_capture`: capture of funds for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/capture/` operation when it takes longer than expected to process on the acquirer side.
         *
         *     ---
         *
         *     `preauthorized`: A preauthorization of a card (authorization of card data without a financial transaction) was executed successfully using this Purchase. See the description of the `.skip_capture` field for more details.
         *
         *     ---
         *
         *     `paid`: Purchase was successfully paid for.
         *
         *     ---
         *
         *     `pending_execute`: Payment (or `hold` in case of `skip_capture`) for this Purchase is in processing, but is not finalized on the acquirer side yet.
         *
         *     ---
         *
         *     `pending_charge`: Recurring payment for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/charge/` operation when it takes longer than expected to process on the acquirer side.
         *
         *     ---
         *
         *     `retrieved`: A retrieval request was registered for this, previously paid, Purchase.
         *
         *     ---
         *
         *     `charged_back`: A chargeback was registered for this, previously paid, Purchase.
         *
         *     ---
         *
         *     `pending_refund`: a refund (full or partial) for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/refund/` operation when it takes longer than expected to process on the acquirer side.
         *
         *     ---
         *
         *     `refunded`: This Purchase had its payment refunded, fully or partially.
         * @default created
         * @enum {string}
         */
        PurchaseStatus: "created" | "sent" | "viewed" | "error" | "cancelled" | "overdue" | "expired" | "hold" | "released" | "pending_release" | "pending_capture" | "preauthorized" | "paid" | "pending_execute" | "pending_charge" | "chargeback" | "pending_refund" | "refunded";
        /** @description State code */
        State: string;
        /** @description Street house number and flat address where applicable */
        StreetAddress: string;
        /**
         * Format: ISO 8601 (YYYY-MM-DD)
         * @example 2020-04-30
         */
        Timestamp: string;
        /**
         * @description Flow or pathway used to initiate or execute a transaction.
         *
         *     - api: transaction initiated via the merchant API
         *     - direct_post: transaction executed via direct POST request
         *     - edd: transaction intialized from Easy Digital Downloads module
         *     - fluentforms: transaction intialized from Fluentforms integration
         *     - formidableforms: transaction intialized from Formidableforms integration
         *     - givewp: transaction intialized from GiveWP integration
         *     - gravityforms: transaction intialized from Gravity Forms integration
         *     - hostbill: transaction intialized from Hostbill integration
         *     - import: transaction imported from external system
         *     - link: transaction initiated via shared link
         *     - magento: transaction intialized from Magento module
         *     - opencart: transaction intialized from OpenCart module
         *     - payform: transaction executed via the gateway payform
         *     - paymattic: transaction intialized from Paymattic integration
         *     - perfexcrm: transaction intialized from Perfex CRM
         *     - prestashop: transaction intialized from PrestaShop module
         *     - server_to_server: transaction executed via server to server API
         *     - shopify: transaction intialized from Shopify integration
         *     - web_office: transaction initiated via the merchant portal
         *     - whmcs: transaction intialized from WHMCS integration
         *     - woocommerce: transaction intialized from Woocommerce module
         *     - woocommerce_subscriptions: transaction intialized from Woocommerce subscriptions module
         *     - wpcharitable: transaction intialized from WPCharitable integration
         *     - wpfunnels: transaction intialized from WPFunnels Pro module
         * @enum {string}
         */
        TransactionFlow: "api" | "direct_post" | "edd" | "fluentforms" | "formidableforms" | "givewp" | "gravityforms" | "hostbill" | "import" | "link" | "magento" | "opencart" | "payform" | "paymattic" | "perfexcrm" | "prestashop" | "server_to_server" | "shopify" | "web_office" | "whmcs" | "woocommerce" | "woocommerce_subscriptions" | "wpcharitable" | "wpfunnels";
        /**
         * @description Product category the transaction belongs to.
         *
         *     - bank_payment: bank_payment (Payment.payment_type == "bank_payment")
         *     - chargeback: Purchase chargeback created through the merchant API (Purchase.product == "chargeback")
         *     - custom_payment: custom_payment (Payment.payment_type == "custom_payment")
         *     - invoice: Purchase created as an invoice through the merchant portal (Purchase.product == "billing_invoices")
         *     - payout: Payout to a client's payment card
         *     - payout_balance_transfer: Transfer of funds between the acquirer and payout balances
         *     - purchase: Purchase created through the merchant API (Purchase.product == "purchases")
         *     - refund: refund (Payment.payment_type == "refund")
         *     - subscription: Purchase created using a subscription (Purchase.product is either "billing_subscriptions" or "billing_subscriptions_invoice")
         * @enum {string}
         */
        TransactionProduct: "bank_payment" | "chargeback" | "custom_payment" | "invoice" | "payout" | "payout_balance_transfer" | "purchase" | "refund" | "subscription";
        /**
         * @description Company turnover statistics
         * @example {
         *       "turnover": 93408,
         *       "fee_sell": 1750,
         *       "count": {
         *         "all": 175
         *       }
         *     }
         */
        Turnover: {
            turnover?: components["schemas"]["MoneyAmount"] & unknown;
            fee_sell?: components["schemas"]["FeeSell"];
            /** @description Transaction counts processed withing the selected filters */
            count?: {
                /** @description Number of transactions that contributed to the turnover. This can be used for calculating average `turnover` and `fee_sell` within the selected filters. */
                all?: number;
            };
        };
        /** @description Incoming and outgoing Company turnover statistics */
        TurnoverPair: {
            incoming?: components["schemas"]["Turnover"];
            outgoing?: components["schemas"]["Turnover"];
        };
        /** Format: url */
        URL: string;
        /**
         * Format: Unix timestamp (seconds)
         * @example 1619740800
         */
        UnixTimestamp: number;
        Webhook: components["schemas"]["BaseModel"] & {
            /** @description Arbitrary title of webhook */
            title: string;
            /**
             * @description Specifies this webhook should trigger on all event types. Either this or `events` is required.
             * @default false
             */
            all_events: boolean;
            public_key?: components["schemas"]["PublicKey"];
            /** @description List of events to trigger webhook callbacks for. Either this or `all_events` is required. */
            events: components["schemas"]["Event"][];
            callback: components["schemas"]["URL"];
        };
        /** @description ZIP or postal code */
        ZIPCode: string;
    };
    responses: {
        /** @description Invalid data submitted or request processing error */
        400: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": Record<string, never>;
            };
        };
        /** @description No such object */
        404: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description OK */
        BillingTemplateClient: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["BillingTemplateClient"];
            };
        };
        /** @description OK */
        BillingTemplate: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["BillingTemplate"];
            };
        };
        /** @description OK */
        Purchase: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Purchase"];
            };
        };
        /** @description OK */
        Payout: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Payout"];
            };
        };
        /** @description OK */
        Payment: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Payment"];
            };
        };
        /** @description OK */
        Client: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Client"];
            };
        };
        /** @description OK */
        ClientRecurringToken: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ClientRecurringToken"];
            };
        };
        /** @description OK */
        Webhook: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Webhook"];
            };
        };
    };
    parameters: {
        /** @description Object ID (UUID) */
        id: string;
        /** @description Filter result set by whether the transaction was performed using a recurring execution token */
        tokenized: boolean;
        /** @description Filter result set to only include values older or equal to the provided Unix timestamp */
        from: number;
        /** @description Filter paid result set to only include values older or equal to the provided Unix timestamp */
        paid_from: number;
        /** @description Filter paid result set to only include values younger than the provided Unix timestamp */
        paid_to: number;
        /** @description Filter result set to only include values younger than the provided last modification time Unix timestamp */
        updated_to: number;
        /** @description Filter result set to only include values older or equal to the provided last modification time Unix timestamp */
        updated_from: number;
        /** @description Filter result set to only include the specified brand UUID(s) */
        brand_id: string;
        /** @description Filter result set to only include the specified shop UUID(s) */
        shop_id: string;
        /** @description Filter result set to only include results including a specified text (search over a ton of text fields) */
        q: string;
        /** @description Filter result set to only include results including a specified text in products */
        products: string;
        /** @description Filter result set to only include results with a total between min and max value. Must include 2 values, if any - (min, max). */
        total: string;
        /** @description Filter result set to only include results with a 3-D verification. */
        three_d_secure: string;
        /** @description Filter result set to only include results with a specific status. See <a href="#model-Purchase">Purchase<a> and <a href="#model-Payout">Payout<a> for more information. */
        status: string;
        /** @description Filter result set to only include values younger than the provided Unix timestamp */
        to: number;
        /** @description Filter result set to only include the specified brand UUID(s) */
        brand: string;
        /** @description Filter result set to only include the specified terminal UUID(s) */
        terminal_uid: string;
        /** @description Filter result set to only include specified currency(ies) */
        currency: string;
        /** @description Filter result set to only include specified payment methods(s). See <a href="#model-PaymentMethod">PaymentMethod<a> fro more information. */
        payment_method: components["schemas"]["PaymentMethod"];
        /** @description Filter result set to only include specified products(s). See <a href="#model-TransactionProduct">TransactionProduct<a> fro more information. */
        product: components["schemas"]["TransactionProduct"];
        /** @description Filter result set to only include specified transaction creation or execution flow(s). See <a href="#model-TransactionFlow">TransactionFlow<a> fro more information. */
        flow: components["schemas"]["TransactionFlow"];
        /** @description Filter result set to only include specified client country(ies) in ISO 3166-1 alpha-2 format */
        country: string;
        /** @description Filter result set to only include specified banking account UUID(s) */
        banking_account: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    purchases_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "client": {
                 *         "email": "test@test.com"
                 *       },
                 *       "purchase": {
                 *         "products": [
                 *           {
                 *             "name": "test",
                 *             "price": 100
                 *           }
                 *         ]
                 *       },
                 *       "brand_id": "409eb80e-3782-4b1d-afa8-b779759266a5"
                 *     } */
                "application/json": components["schemas"]["Purchase"];
            };
        };
        responses: {
            201: components["responses"]["Purchase"];
            400: components["responses"]["400"];
        };
    };
    purchases_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Purchase"];
            404: components["responses"]["404"];
        };
    };
    purchases_cancel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Purchase"];
            404: components["responses"]["404"];
        };
    };
    purchases_release: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Purchase"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    purchases_capture: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Amount to be captured. Used to perform partial captures. Remainder will be automatically released. */
                    amount?: number;
                };
            };
        };
        responses: {
            200: components["responses"]["Purchase"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    purchases_charge: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "recurring_token": "ea582899-78ec-4c3a-9cb3-08f922e556b6"
                 *     } */
                "application/json": {
                    /**
                     * Format: uuid
                     * @description ID of a recurring token (Purchase having `is_recurring_token == true`) to use.
                     */
                    recurring_token?: string;
                };
            };
        };
        responses: {
            200: components["responses"]["Purchase"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    purchases_delete_recurring_token: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Purchase"];
            404: components["responses"]["404"];
        };
    };
    purchases_refund: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "amount": 120
                 *     } */
                "application/json": {
                    /** @description Amount to refund in minor units of the purchase's currency - e.g. `100` for €1.00. Should not be more than `Purchase.refundable_amount`.
                     *
                     *     Optional; if not provided, a full refund will be executed. See the description for `Purchase.refund_availability` field. */
                    amount?: number;
                };
            };
        };
        responses: {
            200: components["responses"]["Payment"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    purchases_mark_as_paid: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "paid_on": 1635162311
                 *     } */
                "application/json": {
                    /** @description UTC timestamp at which this purchase was paid. Current time will be used if omitted. */
                    paid_on?: number;
                };
            };
        };
        responses: {
            200: components["responses"]["Purchase"];
            404: components["responses"]["404"];
        };
    };
    purchases_resend_invoice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Purchase"];
            404: components["responses"]["404"];
        };
    };
    payment_methods: {
        parameters: {
            query: {
                /** @description Which brand would you like to lookup the available payment methods for. Use the same value (UUID) you'd set the `Purchase.brand_id` to. */
                brand_id: string;
                /** @description Currency you'd use in your Purchase in ISO 4217 format, e.g. `EUR`. */
                currency: string;
                /** @description Country code in the ISO 3166-1 alpha-2 format (e.g. `GB`). Optional. */
                country?: string;
                /** @description If provided in the format of `recurring=true`, will filter out the methods that don't support recurring charges (see `POST /purchases/{id}/charge/`). */
                recurring?: boolean;
                /** @description If provided in the format of `skip_capture=true`, will filter out the methods that don't support `skip_capture` functionality (see the description for `Purchase.skip_capture field`). */
                skip_capture?: boolean;
                /** @description If provided in the format of `preauthorization=true`, will filter out the methods that don't support preauthorization functionality (see the description for `Purchase.skip_capture field`). */
                preauthorization?: boolean;
                /** @description Language code in the ISO 639-1 format (e.g. 'en'). Optional. */
                language?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        available_payment_methods?: string[];
                        /** @description Payment method names (as returned by `available_payment_methods`) grouped by country codes they are available in. `any` key returns names of payment method available in all countries. */
                        by_country?: {
                            any?: string[];
                        } & {
                            [key: string]: string[];
                        };
                        /** @description Human-readable names corresponding to country codes as returned by `by_country` property. `any` code is also decoded to `Other`. */
                        country_names?: {
                            [key: string]: string;
                        };
                        /** @description Human-readable names of payment methods as returned by `available_payment_methods` property. */
                        names?: {
                            [key: string]: string;
                        };
                        /** @description Mapping of payment method names to respective logo file paths (relative to the hostname of API host). Some methods can be displayed as an array of logos. */
                        logos?: {
                            [key: string]: string | string[];
                        };
                        card_methods?: string[];
                    };
                };
            };
            400: components["responses"]["400"];
        };
    };
    payout_methods: {
        parameters: {
            query: {
                /** @description Which brand would you like to lookup the available payout methods for. Use the same value (UUID) you'd set the `Payout.brand_id` to. */
                brand_id: string;
                /** @description Currency you'd use in your Payout in ISO 4217 format, e.g. `EUR`. */
                currency: string;
                /** @description Language code in the ISO 639-1 format (e.g. 'en'). Optional. */
                language?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        available_payout_methods?: string[];
                        /** @description Human-readable names of payout methods as returned by `available_payout_methods` property. */
                        names?: {
                            [key: string]: string;
                        };
                        /** @description Mapping of payout method names to respective logo file paths (relative to the hostname of API host). Some methods can be displayed as an array of logos. */
                        logos?: {
                            [key: string]: string | string[];
                        };
                        card_methods?: string[];
                    };
                };
            };
            400: components["responses"]["400"];
        };
    };
    payouts_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "client": {
                 *         "email": "test@example.com"
                 *       },
                 *       "payment": {
                 *         "amount": 10000,
                 *         "currency": "EUR",
                 *         "description": "This is a description"
                 *       },
                 *       "brand_id": "f025d78f-3d23-49d1-a377-e2bf7e318a25"
                 *     } */
                "application/json": components["schemas"]["Payout"];
            };
        };
        responses: {
            201: components["responses"]["Payout"];
            400: components["responses"]["400"];
        };
    };
    payouts_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Payout"];
            404: components["responses"]["404"];
        };
    };
    billing_templates_one_time_invoices: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    clients: components["schemas"]["BillingTemplateClient"][];
                } & components["schemas"]["BillingTemplate"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["parameters"]["id"][];
                };
            };
            400: components["responses"]["400"];
        };
    };
    billing_templates_list: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BillingTemplate"][];
                        /** @description The next page of pagination results. `null` if there are no more results. */
                        next?: string | null;
                        /** @description The previous page of pagination results. `null` if there was no previous page. */
                        previous?: string | null;
                    };
                };
            };
        };
    };
    billing_templates_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BillingTemplate"];
            };
        };
        responses: {
            201: components["responses"]["BillingTemplate"];
            400: components["responses"]["400"];
        };
    };
    billing_templates_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["BillingTemplate"];
            404: components["responses"]["404"];
        };
    };
    billing_templates_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BillingTemplate"];
            };
        };
        responses: {
            200: components["responses"]["BillingTemplate"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    billing_templates_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    billing_templates_send_invoice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "client_id": "b79d3df6-2f69-4426-acee-eda049d83e18"
                 *     } */
                "application/json": components["schemas"]["BillingTemplateClient"];
            };
        };
        responses: {
            200: components["responses"]["Purchase"];
            400: components["responses"]["400"];
        };
    };
    billing_templates_add_subscriber: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "client_id": "b79d3df6-2f69-4426-acee-eda049d83e18"
                 *     } */
                "application/json": components["schemas"]["BillingTemplateClient"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        billing_template_client?: components["schemas"]["BillingTemplateClient"];
                        /** @description Nullable in `POST /billing_templates/{id}/add_subscriber/` response. */
                        purchase?: components["schemas"]["Purchase"];
                    };
                };
            };
            400: components["responses"]["400"];
        };
    };
    billing_templates_clients_list: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BillingTemplateClient"][];
                        /** @description The next page of pagination results. `null` if there are no more results. */
                        next?: string | null;
                        /** @description The previous page of pagination results. `null` if there was no previous page. */
                        previous?: string | null;
                    };
                };
            };
        };
    };
    billing_templates_clients_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["BillingTemplateClient"];
            404: components["responses"]["404"];
        };
    };
    billing_templates_clients_partial_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "status": "active"
                 *     } */
                "application/json": components["schemas"]["BillingTemplateClient"];
            };
        };
        responses: {
            200: components["responses"]["BillingTemplateClient"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    clients_list: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Client"][];
                        /** @description The next page of pagination results. `null` if there are no more results. */
                        next?: string | null;
                        /** @description The previous page of pagination results. `null` if there was no previous page. */
                        previous?: string | null;
                    };
                };
            };
        };
    };
    clients_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Client"];
            };
        };
        responses: {
            201: components["responses"]["Client"];
            400: components["responses"]["400"];
        };
    };
    clients_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Client"];
            404: components["responses"]["404"];
        };
    };
    clients_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Client"];
            };
        };
        responses: {
            200: components["responses"]["Client"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    clients_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    clients_partial_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Client"];
            };
        };
        responses: {
            200: components["responses"]["Client"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    client_recurring_tokens_list: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ClientRecurringToken"][];
                        /** @description The next page of pagination results. `null` if there are no more results. */
                        next?: string | null;
                        /** @description The previous page of pagination results. `null` if there was no previous page. */
                        previous?: string | null;
                    };
                };
            };
        };
    };
    client_recurring_tokens_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ClientRecurringToken"];
            404: components["responses"]["404"];
        };
    };
    client_recurring_tokens_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhooks_list: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Webhook"][];
                        /** @description The next page of pagination results. `null` if there are no more results. */
                        next?: string | null;
                        /** @description The previous page of pagination results. `null` if there was no previous page. */
                        previous?: string | null;
                    };
                };
            };
        };
    };
    webhooks_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Webhook"];
            };
        };
        responses: {
            201: components["responses"]["Webhook"];
            400: components["responses"]["400"];
        };
    };
    webhooks_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Webhook"];
            404: components["responses"]["404"];
        };
    };
    webhooks_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Webhook"];
            };
        };
        responses: {
            200: components["responses"]["Webhook"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    webhooks_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhooks_partial_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Webhook"];
            };
        };
        responses: {
            200: components["responses"]["Webhook"];
            400: components["responses"]["400"];
            404: components["responses"]["404"];
        };
    };
    public_key: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Public key for authenticating callback payloads */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PublicKey"];
                };
            };
        };
    };
    turnover: {
        parameters: {
            query?: {
                /** @description Filter result set by whether the transaction was performed using a recurring execution token */
                tokenized?: components["parameters"]["tokenized"];
                /** @description Filter result set to only include values older or equal to the provided Unix timestamp */
                from?: components["parameters"]["from"];
                /** @description Filter result set to only include values younger than the provided Unix timestamp */
                to?: components["parameters"]["to"];
                /** @description Filter result set to only include the specified brand UUID(s) */
                brand?: components["parameters"]["brand"];
                /** @description Filter result set to only include the specified terminal UUID(s) */
                terminal_uid?: components["parameters"]["terminal_uid"];
                /** @description Filter result set to only include specified currency(ies) */
                currency?: components["parameters"]["currency"];
                /** @description Filter result set to only include specified payment methods(s). See <a href="#model-PaymentMethod">PaymentMethod<a> fro more information. */
                payment_method?: components["parameters"]["payment_method"];
                /** @description Filter result set to only include specified products(s). See <a href="#model-TransactionProduct">TransactionProduct<a> fro more information. */
                product?: components["parameters"]["product"];
                /** @description Filter result set to only include specified transaction creation or execution flow(s). See <a href="#model-TransactionFlow">TransactionFlow<a> fro more information. */
                flow?: components["parameters"]["flow"];
                /** @description Filter result set to only include specified client country(ies) in ISO 3166-1 alpha-2 format */
                country?: components["parameters"]["country"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Company turnover successfully retrieved */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TurnoverPair"];
                };
            };
            400: components["responses"]["400"];
        };
    };
    balance: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Balance data successfully retrieved */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompanyBalance"];
                };
            };
            400: components["responses"]["400"];
        };
    };
    company_statements_list: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CompanyStatement"][];
                        /** @description The next page of pagination results. `null` if there are no more results. */
                        next?: string | null;
                        /** @description The previous page of pagination results. `null` if there was no previous page. */
                        previous?: string | null;
                    };
                };
            };
        };
    };
    company_statements_create: {
        parameters: {
            query?: {
                /** @description Filter result set to only include values older or equal to the provided Unix timestamp */
                from?: components["parameters"]["from"];
                /** @description Filter result set to only include values younger than the provided Unix timestamp */
                to?: components["parameters"]["to"];
                /** @description Filter paid result set to only include values older or equal to the provided Unix timestamp */
                paid_from?: components["parameters"]["paid_from"];
                /** @description Filter paid result set to only include values younger than the provided Unix timestamp */
                paid_to?: components["parameters"]["paid_to"];
                /** @description Filter result set to only include values older or equal to the provided last modification time Unix timestamp */
                updated_from?: components["parameters"]["updated_from"];
                /** @description Filter result set to only include values younger than the provided last modification time Unix timestamp */
                updated_to?: components["parameters"]["updated_to"];
                /** @description Filter result set to only include the specified brand UUID(s) */
                brand_id?: components["parameters"]["brand_id"];
                /** @description Filter result set to only include the specified shop UUID(s) */
                shop_id?: components["parameters"]["shop_id"];
                /** @description Filter result set to only include results including a specified text (search over a ton of text fields) */
                q?: components["parameters"]["q"];
                /** @description Filter result set to only include results including a specified text in products */
                products?: components["parameters"]["products"];
                /** @description Filter result set to only include results with a total between min and max value. Must include 2 values, if any - (min, max). */
                total?: components["parameters"]["total"];
                /** @description Filter result set to only include specified currency(ies) */
                currency?: components["parameters"]["currency"];
                /** @description Filter result set to only include specified payment methods(s). See <a href="#model-PaymentMethod">PaymentMethod<a> fro more information. */
                payment_method?: components["parameters"]["payment_method"];
                /** @description Filter result set to only include results with a 3-D verification. */
                three_d_secure?: components["parameters"]["three_d_secure"];
                /** @description Filter result set to only include specified client country(ies) in ISO 3166-1 alpha-2 format */
                country?: components["parameters"]["country"];
                /** @description Filter result set to only include results with a specific status. See <a href="#model-Purchase">Purchase<a> and <a href="#model-Payout">Payout<a> for more information. */
                status?: components["parameters"]["status"];
                /** @description Filter result set to only include specified products(s). See <a href="#model-TransactionProduct">TransactionProduct<a> fro more information. */
                product?: components["parameters"]["product"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "format": "csv",
                 *       "timezone": "UTC"
                 *     } */
                "application/json": components["schemas"]["CompanyStatement"];
            };
        };
        responses: {
            /** @description OK */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompanyStatement"];
                };
            };
            400: components["responses"]["400"];
        };
    };
    company_statements_read: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompanyStatement"];
                };
            };
            404: components["responses"]["404"];
        };
    };
    company_statements_cancel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object ID (UUID) */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompanyStatement"];
                };
            };
            404: components["responses"]["404"];
        };
    };
}
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
